---
title: 计算机网络
date: 2022-03-26 22:59:11
tags: 计算机网络
categories: Interview
---

- ## 知识点：

  - ### 进程和线程

    - 进程：内存中正在运行的应用程序

    - 线程：进程的最小执行单位

    - 浏览器采取了多进程模型（至少4个）

      - 浏览器进程主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。

      - 渲染进程 核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都运行在该进程中，默认情况下，Chrome为每一个Tab标签页创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下的。

      - GPU进程。GPU图形处理器（英语：graphics processing unit，缩写：GPU）,负责3D css效果，网页，Chrome ui的绘制。

      - 网络进程主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立处理，成为单独一个进程。

      - 插件进程。主要负责插件的运行，因为插件易崩溃，所以通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

  - ### 计算机网络的ISO七层模型

    - 1、物理层：
      - 使用一定的物理介质(光纤，网线wifi）

    - 2、数据链路层：MAC地址 封裝 单位为byte
      - 通过网关进行通信 

    - 3、网络层：
      - IP协议：将数据从主机A发送给主机B，不能保证肯定发送给目标

    - 4、传输层：具有端口，确保数据传输

      - UDP(用户数据包协议）——只管发不管收——DNS

      - TCP(传输控制协议)：

        - 重传机制

        - 排序机制：
          将主机A发给B的多个数据包按照编号进行排序进行重组，保证完整性

          

        - 相关面试题：TCP和UDP区别:面向连接/可靠性/基于字节流/TCP三次握手/TCP四次挥手

    - 5、会话层:
      - 断点续传

    - 6、表示层——翻译——解决不同系统数据之间传输的问题

    - 7、应用层：#问题
      - HTTP协议：

  - ### HTTP请求流程

    - 浏览器发送HTTP请求 

      - 1、构造请求行：GET /api/article HTTP/1.1

      - 2、查找缓存：有就去缓存存，没有呢就发选网络请求

      - 3、准备IP地址和端口号

      - 4、 等待TCP队列:因为一个域名最多只能生立6个TCP连接

      - 5、建立TCP连接

      - 6、发送HTTP请求

      - 版本2:

        - 1、先查找缓存，检测缓存是否过期，直接返回缓存中内容

        - 2、看域名是否被解析，DNS协议，DNS协议是基于UPD协议  ip+端口号 

        - 3、ip地址寻址，排队等候，最多发送6个http请求

        - 4、tcp创建链接，用户传输(三次握手)

        - 5、利用tcp传输数据(拆分数据包，有序)  可靠，有序，服务器会按照顺序来接受

        - 6、http请求(请求行，请求头，请求体)

        - 7、默认不会断开keep-alive，为下次传输数据是，可以复用上次的创建的连接

        - 8、服务器接受数据后(响应行 响应头 响应头)

  - ### 输入url地址到显示的过程

    - 进程角度：

    - 其他角度

- ## 常见面试题

  - ### 一次完整的http服务过程

    - 一次完整的http服务的几个阶段

    - html的渲染过程

    - 常见的http请求状态码

  - ### 传输层——TCP/UDP相关

    - #### TCP和UDP区别:面向连接/可靠性/基于字节流

      - TCP是基于连接的，可靠性高(有状态/可控制/TCP流量控制/TCP拥塞控制)，安全，但是相同数据下开销大；只支持点到点连接，面向字节流

        - 有状态；TCP会精准记录哪些数据发送了，被对方接受了，哪些没有，而保证数据按序到达，不允许差错 

        - 可控制；意识到丢包或者网络环境差，TCP根据具体情况调整自己的行为，控制自己发送速度或重发

      - UDP是基于无连接的，可靠性较低，实时性高，会存在丢包问题，支持多种连接方式

      - 应用场景的区别：

        - 如果对实时性要求高和高速传输/可靠性要求低追求效率的场景下需要使用UDP；

        - 如果需要传输大量数据且对数据可靠性要求高的场景使用TCP；

    - #### TCP三次握手

      - 握手过程：确认双方的两样能力: 发送的能力和接收的能力

        

        - 1.最开始双方都属于CLOSED状态。然后服务器开始监听某个端口，进入LISTEN状态。

        - 2.客户端注重发起连接，发送SYN，自己变成了SYN-SENT状态

        - 3.服务端收到，返回SYN和ACK（对应客户端发来的SYN），自己变成了SYN-REVD

        - 4.客户端再发送ACK给服务端，自己变成ESTABLISHED（established）状态；服务端收到ACK之后，也变成这个状态

        - \#注意：SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1
          凡是需要对端确认的，一定消耗TCP报文的序列号。

      - 为什么不是两次？
        - 两次握手只能确定从 客户端 到 服务端 的网络是可达的，但却无法保证从 服务端 到 客户端 的网络是可达的。第三次握手就是为了确定从 服务端 到 客户端 的网络是否可达，两次握手，服务端只要接收到然后发送相应的数据包，就 默认连接 了 ，但是事实上现在客户端可能已经断开连接了，这样也就带来了连接资源的浪费 

      - 为什么不是四次？
        - 当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。

      - 三次握手过程中可以携带数据么？
        - 可以，但是只有第三次，此时的established状态相对安全并且够确认服务器的接收发送能力。而不能在第一次握手携带数据是为了防止黑客在syn中放入大量数据造成服务器资源的消耗。

    - #### TCP四次挥手

      - 过程

        

        - 首先客户端主动关闭，向服务器发FIN报文

        - 服务端接收后通知应用进程并向客户端发送ACK确认

        - 服务端处理完后被动关闭再次向客户端发送FIN以及ACK，进入LAST-ACK状态，

        - 客户端收到服务端发来的FIN后，发送 ACK 给服务端。在等待2MSL后进入CLOSED状态

      - \#问题 为什么要等待2MSL（最长报文段寿命）

        如果客户端没有收到服务端的重发请求，表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。

        - 1 个 MSL 确保四次挥手中第四步的ACK可以准确到达

        - 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达

        - 如果不等待：
          当服务端还有很多数据包要给客户端发，此时客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。

      - 为什么不是三次？

        - 如果三次，服务端将ACK和FIN的发送合并为一次挥手，这个时候为了传递没有完成的数据，长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。

        - 因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。

    - #### SYN Flood 攻击原理

      - 原理:典型的 DoS/DDoS 攻击。用客户端在短时间内伪造大量不存在的 IP地址，并向服务端疯狂发送SYN。

        - 处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。

        - 由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。

      - 应对方法: 

        - 增加 SYN 连接，也就是增加半连接队列的容量。

        - 减少 SYN + ACK 重试次数，避免大量的超时重发。

        - 利用 SYN Cookie技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证Cookie 合法之后才分配连接资源。

    - #### TCP 短连接和长连接的区别

      - 短连接：

        - Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。

        - 优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。

      - 长连接：

        - Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

        - 应对策略：

          - 关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；

          - 以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。

    - #### TCP可靠性特质

      - TCP流量控制

      - TCP拥塞控制

    - #### 粘包拆包问题（消息边界问题）

      - 场景

        

        假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。

        - 成功结果：服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；

        - 失败1：服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；

        - 失败2：服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；

        - 失败3：服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。

      - 如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。
