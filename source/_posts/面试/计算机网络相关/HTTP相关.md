---
title: HTTP相关
date: 2022-03-27 22:50:51
tags: 计算机网络
categories: Interview
---

# 应用层-HTTP、HTPS、DNS

## HTTP的特点？它有什么缺点？

### 特点： 

- 端对端， 灵活可拓展，

- 基于 TCP/IP->可靠

- 每一次请求都是独立无关的-> 无状态

### 缺点：

- 明文传输(不加密)，无法验证报文的完整性，不验证通信方的身份，内容可能被窃听、被篡改。

- 无状态，它是缺点也是优点吧，分不同的场景。

- 队头阻塞——HTTP2多路复用解决

  - HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。

  - HTTP2中：

    - 同域名下所有通信都在单个连接上完成。单个连接可以承载任意数量的双向数据流。

    - 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装

## HTTP请求报文（客户端）

### 常用请求方法：

- GET: 通常用于请求服务器发送某些资源

- POST: 发送数据给服务器

- PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式

- DELETE: 用于删除指定的资源

- CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器

- OPTIONS: 用于获取目的资源所支持的通信选项

### GET(检索&&获取）/POST（创建||更新）区别

- 参数角度：get在URL中，post在请求体中,并且post支持更多数据类型

- 缓存安全性不同：浏览器一般会对 Get 请求缓存，很容易通过历史记录、缓存查到数据信息。但很少对 Post 请求缓存。get可以回退/post不可以回退

- 数据类型不同：get使用url发送数据，使用的百分号编码,不是简单的ASCII码（比如{，不能够在url直接使用）

- 应用场景：get安全幂等，不会引起服务器状态变化。
  - 自己理解的话：在没有其他操作的情况下，get多次请求结果和一次请求结果相同。post非安全非幂等。

### PUT和POST都可以给服务器新增资源，有什么区别？

- PUT：幂等，URI指向单一资源。

- POST：非幂等，URI指向资源集合。

- eg：比如博客系统，创建新文章，用POST https://www.blog.com/articles,多次调用，就创建多个文章。如果更新指定文章的标题，用PUT https://www.blog.com/articles/000001,多次调用，和第一次调用效果相同。

### http 请求方法 options 方法有什么用？

- 旨在发送一种探测请求，以确定针对某个目标地址的请求必须具有怎么样的约束，然后根据约束发送真正的请求。

- 应用场景：针对跨域资源的预检，处理跨域请求。就是采用 HTTP 的 OPTIONS 方法先发送的。

## 常见状态码：

## HTTP响应报文（服务端）

## HTTP的keep-alive是干什么的？

- 早期HTTP/1.0每次请求都要重新建立一次连接，为了减少资源消耗、缩短响应时间，就要重用连接，想要保持长连接，需要在请求头上加上Connection:keep-alive。

## HTTP1.1 和 HTTP 1.0之向区别

- HTTP/1.0有GET、POST、HEAD三个请求方法

- HTTP/1.1新增了PUT、DELETE、PATCH、OPTIONS、TRACE、CONNECT 请求方法，并且支持了持久连接。

## DNS 为什么使用 UDP协议作为传输层协议?

## HTTPS

### 	RSA 加密(非对称加密)

### 	TLS/SSL证书

- TLS/SSL 中什么一定要用三个随机数，来生成"会话密钥"

- SSL连按断开后如何饭复？

## 浏览器存储

### 强缓存和协商缓存

- 浏览器缓存在加载页面中的应用

  - 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）

  - 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）

  - 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）

- 强缓存(Cache-Control)：只有首次请求和服务器通信，读取缓存不用向服务器发送请求。返回200

- 协商缓存(ETag/If-None-Match)：总会与服务器交互，第一次是拿数据和ETag，之后凭ETag询问是否更新。返回304，从现有缓存加载资源 

## cookie/localStorage/sessionStorage三者区别

### Cookie和Session

## CDN服务

- CDN服务是什么

- 负载平衡的两种实现方式？

- 什么是正向代理和反向代理？

## 常见的网络攻击方法和解决方案？

### XSS（跨站脚本攻击）——获取被攻击者的账户信息

- 攻击手段：攻击者往Web页面插入恶意<script>代码，当用户浏览页面时，嵌入其中的script恶意代码就会执行。将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

- 场景：

  - 拼接url 获取用户敏感数据

  - 后台存在漏洞拼接sql 盗取数据库信息

- 解决方案：

  - 过滤<script>、<img>、<a>标签

  - 对<、>在输入的时候进行编码转换

  - 限制字符串长度

  - 使用 HttpOnly Cookie
    将重要的cookie标记为httponly，当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。

### CSRF（跨站请求伪造）——通过账号信息伪装成被攻击者实施攻击行为

- 攻击手段：用户登录受信任的A网站，产生Cookie，在没有登出A的情况下，访问了危险的B网站，B要求访问第三方站点（A），并发送一个请求（request），然后B就带着之前的Cookie（伪装成用户的名义）去请求。

- 解决方案：

  - 1.验证 HTTP Referer 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer记录了该 HTTP 请求的来源地址。

    - 优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。

    - 缺点：Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。

  -  2.在请求地址中添加 token 并验证。在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

    - 优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。

    - 缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。

## 实现多个网站共享登陆状态/浏览器内多个标签页之间的通讯
