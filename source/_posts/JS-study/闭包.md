---
title: 闭包(愤怒学习版小谭)
date: 2022-05-21 22:10:55
tags: JS
categories: 
---

闭包，令人头大的问题，从没了解过到了解了又没完全了解的状态，彻底仔仔细细看了一下（怎么也想不到是因为在面试里知道不被尊重是什么样子刺激了我，究其原因还是我菜吧，2022.5.20 5:00-5:15 我要记住！）

回到正题，回答：（词法作用域还不是很理解...

- 闭包是一个函数，去看了红宝书，说它是一个有权访问外部作用域中变量的函数
- 它主要作用是：
  - 私有化数据，保护里边的私有变量不受外界的干扰
  - 保存即将要被销毁的数据
    - 一般的函数执行会在内存中创建一个私有作用域，在执行结束之后就会被清除，但是<u>使用了闭包后，闭包内部始终在引用外部函数的变量</u>
    - 根据内存回收机制：某一变量或者对象被引用着，代表着被使用，回收器不会对正在引用的变量或对象回收的，所以不会被立即清除。
- 缺点：
  - 导致内存泄漏（也有可能是忘记写var 变量就都变成全局的了
  - 防止内存泄漏的方法：
    - 使用严格模式，避免不经意间的全局变量泄露
    - 关注 `DOM` 生命周期，在销毁阶段记得解绑相关事件：定时器记得销毁！！
    - 避免过度使用闭包

## 理解：

- 访问其他函数内部变量
- 使一些特有变量不被内存回收机制回收
- 避免全局变量被污染，方便调用上下文的局部变量，加强封装性

## 场景：

- Tab中的index/for循环中的函数/回调函数（同理）

  ```js
  var arr = [];
  for(var i = 0; i< 5; i++){      
    arr[i] = function(){           
      return i;      
    } } 
  
  arr[0](); // 5
  ```

  **原因：**(原理我理解的都是差不多的...)

  - **<u>tab选项卡的click事件</u>**：所有的事件绑定都是异步的，当触发点击事件，产生了异步，执行方法的时候，循环早就结束了。因此for循环的i值不能对应到点击事件的i值
    - 触发异步的条件：ajax/事件绑定/setTimeout()/setInterval()

  - **<u>对于for循环函数</u>**：首先`return i`会在私有作用域查找 i 的值，此时私有作用域没有 i ，就回去全局作用域查找，此时全局作用域的 i 经过for循环已经被改变。所以说，要创建一个私有作用域的 i 。

  **解决方法1：**用闭包的思路是让i在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前i的值，每个作用域的i是独立不影响的，也就避免了共用 i，而 i 到最后都是5的问题。

  **缺点：**生成多个不销毁的私有作用域（堆内存），对性能有一定的影响。

  ```js
  var arr = []; 
  for(var i = 0; i< 5; i++){      
    arr[i] = (function(i){           
      return function(){                
        return i;           
      }      
    })(i) //创建一个匿名函数并立刻执行
  } 
  arr[0](); // 0
  ```

  **解决方法2：**使用let变量声明块级作用域

- 封装私有属性：保证了只能访问闭包的属性，而不能修改/查看外部变量

  ```js
  // 模拟私有属性
  function getGeneratorFunc () {
    var _name = 'John';
    var _age = 22;
      
    return function () {
      return {
        getName: function () {return _name;},
        getAge: function() {return _age;}
      };
    };
  }
  
  var obj = getGeneratorFunc()();
  obj.getName(); // John
  obj.getAge(); // 22
  obj._age; // undefined  访问外部的_age就不可以
  ```

  

  

  

  
