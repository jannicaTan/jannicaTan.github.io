[{"title":"JavaScript-运算符：短路运算/赋值运算","url":"/JavaScript/JS-study/%E8%BF%90%E7%AE%97%E7%AC%A6-2021-12.html","content":"1.短路运算(逻辑中断)原理： 当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值\n①逻辑与语法：表达式1 &amp;&amp; 表达式2\n如果第一个表达式的值为真，则返回表达式2\n如果第一个表达式的值为假，则返回表达式1\nconsole.log(123 &amp;&amp; 456);   //456console.log(0 &amp;&amp; 456);     //0console.log(123 &amp;&amp; 456 &amp;&amp; 789);  //789\n\n②逻辑或语法：表达式1 || 表达式2\n如果第一个表达式的值为真，则返回表达式1\n如果第一个表达式的值为假，则返回表达式2 21302004高校实验室安全基础（通识B）.pdf \nconsole.log(123 || 456); //123console.log(0 || 456);   //456console.log(123 || 456 || 789);  //123\n\nvar num = 0;console.log(123 || num++);// 先返回在加，相当于 (123 || 0)console.log(num);    // 123\n\n2.赋值运算符概念： 用来把数据赋值给变量的运算符。\n\n\n\n赋值运算符\n说明\n案例\n\n\n\n=\n直接赋值\nvar usrName = ‘我是值’\n\n\n+= ，-=\n加，减一个数后再赋值\nvar age = 10； age+=5；//15\n\n\n*=，/=，%=\n成，除，取模后再赋值\nvar age = 2; age*=5; //10\n\n\nvar age = 10;age += 5;  // 相当于 age = age + 5;age -= 5;  // 相当于 age = age - 5;age *= 10; // 相当于 age = age * 10;\n\n","categories":["JavaScript"],"tags":["JS基础语法"]},{"title":"关于配置hexo的坑及解决办法","url":"/Hexo/hexo/mis_config_hexo-2021-12.html","content":"最近在学习配置hexo，遇到了一些安装坑，去搜解决方式还遇到了网上不负责任的回答。于是决定还是记录下来 再有人和我一样的情况也不用抓耳挠腮了 \n本文只针对我遇到的问题和解决方式 如有不对还请指出 \n环境及主题：我使用的hexo+Github的配合\n主题:keep主题,很推荐 整个的配置教程很清晰\n这里放上github地址：https://github.com/XPoet/hexo-theme-keep\n1.关于指令：keep g: 生成文件\nkeep deploy: 部署文件\nkeep s:可以在本地预览修改后的样子 \n在正式提交前 可以在本地预览到满意再提交！不用一遍遍的提交去线上查看！！\n2.关于修改背景图片，部署到线上后，显示空白首先打开开发者模式，在控制台查看是否图片报错，如果报错，多半是url出问题了,返回主题的配置文件中修改你的url就可以了\n3.关于keep主题分类/标签创建后，不能正确显示分类及个数3.1生成“分类”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令\n$ hexo new page categories\n\n找到source/categories/index.md这个文件，添加type: &quot;categories&quot;到内容中：\n---title: category //这里注意一定要与themes/keep/layout/page.ejs中的关于分类的title一致date: 2021-12-21 18:07:36type: &quot;categories&quot;---\n\n保存并关闭文件。\n❗️关于不能正确显示分类及个数检查两点❗️\n\nkeep主题：\n检查这里的title名是否与themes/keep/layout/page.ejs中的关于分类的title一致：应为category或者categories\n\n\n非keep主题:\n找到主题对应的themes/keep/layout/再其下方文件中找到关于分类的xxx.ejs文件复制文件名，返回source/categories/index.md添加一行layout: xxx.ejs即可\n\n\n\n3.2 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。\n---title: 文章标题date: XXXXXcategories: 文章对应的分类（自拟）---\n\n⚠️注意：只有添加了categories: xxx的文章才会被收录到首页的“分类”中。\n4.关于hexo多终端同步的问题我找到两个方法，目前我使用的是第一种，这两种方法的解答都将多终端解释的比较清楚，可以自行选择\n\nhttps://www.jianshu.com/p/fceaf373d797\nhttps://www.zhihu.com/question/21193762\n直上云霄的回答\nhttp://fangzh.top/2018/2018090715/\n\n\n\n5.未待完续","categories":["Hexo"],"tags":["Hexo"]},{"title":"DOM-Day1-DOM元素","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM_Day1-2022-01.html","content":"- DOM简介- DOM树\n\n文档：document\n标签：element\n节点-内容：node 标签/属性/文本/注释等\n\n\n- 获取元素- 根据ID获取——getElementById\n参数\n**element**是一个 Element 对象。如果当前文档中拥有特定ID的元素不存在则返回null.\n**id**是大小写敏感的字符串，代表了所要查找的元素的唯一ID.\n\n\n返回值\n返回一个匹配到 ID 的 DOM Element 对象。若在当前 Document 下没有找到，则返回 null。\n\n\n\n- 根据tag获取——getElementsByTagName(标签名)&lt;script&gt;    // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的    var lis = document.getElementsByTagName(&#x27;li&#x27;);    console.log(lis);    console.log(lis[0]);    // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式,动态变化    for (var i = 0; i &lt; lis.length; i++) &#123;        console.log(lis[i]);    &#125;    // 3. 如果页面中只有一个li 返回的还是伪数组的形式     // 4. 如果页面中没有这个元素 返回的是空的伪数组的形式    // 5. element.getElementsByTagName(&#x27;标签名&#x27;); //    父元素必须是指定的单个元素,不能用伪数组形式作为父元素//    获取的时候不包括父元素本身    // var ol = document.getElementsByTagName(&#x27;ol&#x27;); // [ol]    // console.log(ol[0].getElementsByTagName(&#x27;li&#x27;));    var ol = document.getElementById(&#x27;ol&#x27;);    console.log(ol.getElementsByTagName(&#x27;li&#x27;));&lt;/script&gt;\n\n- H5新增，不能兼容IE6/7/8的方法- 通过类选择器获取元素——getElementByClassName()//根据类名获得某些元素集合        var boxs = document.getElementsByClassName(&#x27;box&#x27;);        console.log(boxs);\n\n- 通过选择器获取元素querySelector()返回指定选择器的第一个元素对象  \nquerySelectorAll()返回指定选择器的所有元素对象集合\n⚠️里面的选择器需要加符号\n\nclass-&gt;’.box’ \n id-&gt;’#nav’\n\nvar firstBox = document.querySelector(&#x27;.box&#x27;);console.log(firstBox);var allBox = document.querySelectorAll(&#x27;.box&#x27;);console.log(allBox);var nav = document.querySelector(&#x27;#nav&#x27;);console.log(nav);var li = document.querySelector(&#x27;li&#x27;);console.log(li);\n\n- 获取特殊元素获取body——document.body\n获取html——document.documentElement\n\n- 事件基础- 事件三要素：事件源、事件类型和事件处理程序。(1)事件源：事件被触发的对象，例如按钮(2)事件类型：如何触发，例如鼠标点击(onclick)(3)事件处理程序：通过一个函数赋值的方式完成\n&lt;button id=&#x27;btn1&#x27;&gt;1+1&lt;/button&gt;&lt;script&gt;    var btn1 =document.querySelector(&#x27;#btn1&#x27;);    btn1.onclick=function()&#123;        alert(&#x27;2&#x27;);    &#125;&lt;/script&gt;\n\n\n\n获得焦点事件——onfocus \n失去焦点事件——onblur\n\n执行事件三步骤：// 1. 获取事件源var div = document.querySelector(&#x27;div&#x27;);// 2.绑定事件 注册事件// div.onclick // 3.添加事件处理程序 div.onclick = function() &#123;    console.log(&#x27;我被选中了&#x27;);&#125;\n\n\n- 操作元素- 改变元素内容——innerText()/innerHTML()- innerText 和 innerHTML的区别\n\n\ninnerText\ninnerHTML\n\n\n\n不识别html标签 非标准\n识别html标签 W3C标准\n\n\n这两个属性是可读写的  可以获取元素里面的内容\n\n\n\n去除空格和换行\n保留空格和换行\n\n\n- 修改元素- 表单input属性修改常用属性：type/value/checked/selected/disabled\n不可以用innerHTML了\n- 样式属性操作——element.style/className我们可以通过 JS 修改元素的大小、颜色、位置等样式。\n\n行内样式：element.style，样式修改较少\n类名样式：element.className，样式修改较多\n\n⚠️注意：1.JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor \n2.JS 修改 style 样式操作，产生的是行内样式，权重比较高\n\n总结\n","categories":["DOM学习"],"tags":["DOM学习-day1"]},{"title":"DOM-day3-DOM操作重点","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM-day3-2022-01.html","content":"三种动态创建元素区别-经典面试题document.write()element.innerHTMLdocument.createElement()DOM重点核心DOM操作创建——3个增加——2个删除——1个修改\n修改元素属性:\n修改元素内容:\n修改表单元素:\n修改元素样式:\n\n查——3类\nDOM API\nH5 新方法：\n利用节点操作获取元素:\n\n属性操作——自定义属性\n设置\nelement.getAttribute()\n\n获取\n\n移除\n\n\n事件操作","categories":["DOM学习"],"tags":["DOM学习-day3"]},{"title":"DOM_day2-自定义属性/节点操作","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM-day2-2022-01.html","content":"排他思想：主要做法：1.所有元素清除样式，使用for循环\n2.给当前元素设置样式，使用this\n实例：\n百度换肤\n表格变色\n表格全选/反选\n\n自定义属性操作：获取元素的属性值(1) element.属性——获取元素本身自带的内置属性\n(2) element.getAttribute(&#39;属性&#39;)——获取自定义属性\n​     get得到获取 attribute 属性的意思，我们程序员自己添加的属性我们称为自定义属性 index\n设置元素的属性值 (1) element.属性= &#39;值&#39;——直接赋值\ndiv.id = &#x27;test&#x27;;div.className = &#x27;navs&#x27;;\n\n (2) element.setAttribute(&#39;属性&#39;, &#39;值&#39;)——针对于自定义属性\ndiv.setAttribute(&#x27;index&#x27;, 2);\n\n移除属性——removeAttribute(属性)div.removeAttribute(&#x27;index&#x27;);\n\n实例：\nTab栏切换\n\nH5自定义属性命名——data-开头dataset——存放了所有以data开头的自定义属性dataset是一个集合，里面存放了所有以data开头的自定义属性，获取其中属性的操作如下：\n⚠️：\n\n如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法\nIE11以上才可应用，兼容性不好\n\nconsole.log(div.dataset);console.log(div.dataset.index);console.log(div.dataset[&#x27;index&#x27;]);\n\n节点操作:一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性\n\n元素节点nodeType 为1\n属性节点nodeType 为2\n文本节点noueType 为多（文本节点包含文字、全修、接行等）\n\n","categories":["DOM学习"],"tags":["DOM学习-day2"]},{"title":"DOM-day4-DOM高级事件","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM-day4-2022-01.html","content":"元素注册事件的两种方式1.传统注册事件——on开头特点:注册时间具有唯一性 同一个元素的同一事件只能设置一个处理函数\n2.事件侦听注册事件——addEventListener(&#39;事件类型&#39;,function()&#123;&#125;,useCapture(true/false))特点:\n (1) 里面的事件类型是字符串 必定加引号 而且不带on\n (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）按顺序执行\n删除事件的两种方式1.传统删除事件——元素名.事件类型=null2.常用——元素名.removeEventListener(&#39;事件类型&#39;,注册事件方法名)3.IE9以下老版本——元素名.detachListener(&#39;事件类型&#39;,注册事件方法名)DOM 事件流的三个阶段三个阶段 捕获阶段-&gt;当前目标阶段-&gt;冒泡阶段1.捕获阶段: addEventListener 第三个参数是 true\n顺着从大到小：document -&gt; html -&gt; body -&gt; father -&gt; son \n点击相应,其他元素没有这个动作 则点击其他元素不会反应,依次向下寻找\n2.冒泡阶段: addEventListener 第三个参数是 false/省略\n顺着从小到大去找点击响应：son -&gt; father -&gt;body -&gt; html -&gt; document\n事件对象——event事件\nevent 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看\n\n事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数\n\n事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的,\n​    比如鼠标点击里面就包含了鼠标的相关信息：鼠标坐标\n​    如果是键盘事件里面就包含的键盘事件的信息：判断用户按下了那个键\n\n这个事件对象我们可以自己命名 比如 event 、 evt、 e\n\n事件对象也有兼容性问题 ie678 \n通过 window.event 兼容性的写法  e = e || window.event;\n\n\nvar div = document.querySelector(&#x27;div&#x27;);div.addEventListener(&#x27;click&#x27;, function(e) &#123;  console.log(e);&#125;)\n\n常见事件对象的属性和方法1.e.target——返回的是触发事件的对象（元素）与this的区别：\n\ne.target 点击了那个元素，就返回那个元素\nthis 哪个元素绑定了这个点击事件，那么就返回绑定该事件的元素\ne.srcElement:适用于低版本:IE6/7/8\n\nvar ul = document.querySelector(&#x27;ul&#x27;);ul.addEventListener(&#x27;click&#x27;, function(e) &#123;  // 我们给ul 绑定了事件  那么this 就指向ul    console.log(this);//ul  // e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target 指向的就是li  console.log(e.target);//li  console.log(e.currentTarget);            &#125;)\n\n2.e.type——返回当前触发的事件类型3.e.preventDefault()——阻止默认行为(事件)实例：\n\n点击超链接不跳转\n点击提交按钮不提交\n\n4.重点：e.stopPropagation()——阻止冒泡防止在底层事件触发上层事件\n事件委托**原理**：给父节点添加侦听器，而不给每个子节点单独设置监听器，利用事件冒泡传到父节点，影响每一个子节点\n**作用**：只操作了一次DOM，提高了效率\n**实例**：为父节点添加操作，用e.target.具体元素内容识别每次操作的子节点\nvar ul=document.querySelector(&#x27;ul&#x27;);ul.addEventListener(&#x27;click&#x27;,function(e)&#123;  e.target.style.backgroundColor=&#x27;pink&#x27;&#125;)\n\n鼠标事件对象——MouseEvent进行相应的鼠标操作事件(click/onmouseover/onmouseout)后返回对应的坐标位置\n1.e.clientX/e.clientY——可视区坐标2.e.pageX/e.pageY——页面文档坐标(滚动页面)滚动页面坐标也会变化的\n3.e.screenX/e.screenY——电脑屏幕坐标**案例**：跟随鼠标的图标操作\n键盘事件进行相应的键盘操作所反馈的信息，执行顺序为:keydown-&gt;keypress-&gt;keyup\n1.keyup——**按下按键弹起后**触发\n2.keypress——按下按键即触发:无法识别功能键\n3.keydown——按下按键即触发:识别功能键\n键盘对象——keyCode激发键盘事件后可以得到相应键的 ASCII码值\n**注意**：\n\n我们的keyup 和keydown事件不区分字母大小写  a 和 A 得到的都是65\n\n我们的keypress 事件,区分字母大小写  a  97 和 A 得到的是65\n\n\n","categories":["DOM学习"],"tags":["DOM学习-day4"]},{"title":"DOM-day5：PC端网页特效","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM-day5-2022-01.html","content":"- 常见 offset 属性的作用——偏移量- 常见 client 属性的作用- 常见 scroll 属性的作用- 三大系列总结：\noffset系列经常用于获得元素位置 offsetLeft offsetTop\nclient经常用于获取元素大小 clientWidth cientHeighe\nscroll 经常用于获取滚动距商 scrolltop scrolileft\n\n⚠️注意：页面滚动的距商通过 window.page xozfset 获得\n- mouseenter/mouseover区别- 封装简单动画函数- 写出网页轮播图案例","categories":["DOM学习"],"tags":["DOM学习-day4"]},{"title":"ES6-01-初始化","url":"/ES6/VUE-study/vue-start-01-2022-02.html","content":"1.ES6初始化1.1 模块化ES6(node version&gt;14.15.1)\n\n快速初始化包管理配置文件\n\nnpm init -p\n\n\n生成package.json文件\n在其中添加\n\n&quot;type&quot;: module\n\n1.2 ES6模块化基本语法\n\n默认导出与默认导入\n\n默认导出\n\n```jsexport default {导出对象}  - 目的:挂载使外界能够访问导出的对象  - ⚠️注意：只允许使用唯一的一次export default- 默认导入  - ```js    import 自定义变量名称 from ‘模块标识符/文件路径.js’\n\n\n\n\n直接导入\n\n导入的时候直接import js文件路径 即可\n\n\n按需导入与导出\n\n按需导出\n\nexport 导出的变量\n\n\n\n\n按需导入\n\nimport {按需导出的对应名称1,名称2….} from 对应js文件\n\n\n⚠️ 注意事项：\n  1.可以多次按需导出\n  2.按需导入的名称要与按需导出的名称保持一致\n  3.可以使用as 重命名名称 进行重命名\n  4.按需导入可以与默认导入一起\n\n\n\n\n","categories":["ES6"],"tags":["ES6"]},{"title":"ES6-02-Promise/aysnc","url":"/ES6/VUE-study/vue-start-02-2022-02.html","content":"关于读取文件1.then-fs第三方包\nnpm install then-fsimport thenFs from then-fs\n\n2.fs自带包\nimport fs from fs\n\nPromise\nPromise是一个构造函数\n\nPromise中catch用法Promise.all()Promise.race()","categories":["ES6"],"tags":["Promise"]},{"title":"ES6-EventLoop/宏任务和微任务","url":"/ES6/VUE-study/vue-start-03-2022-02.html","content":"同步任务和异步任务的执行顺序JS执行顺序\nJS任务分类\n微任务与宏任务的执行顺序\n","categories":["ES6"],"tags":["EventLoop"]},{"title":"Webpack基础配置(待继续更新)","url":"/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/VUE-study/webpack%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE-2022-02.html","content":"\n\n前端工程化\n模块化\njs 的模块化、css 的模块化、资源的模块化\n\n\n组件化\n复用现有的 UI 结构、样式、行为\n\n\n规范化\n目录结构的划分、编码规范化、接口规范化、文档规范化、 Git 分支管理\n\n\n自动化\n自动化构建、自动部署、自动化测试\n\n\n\n\nWebpack\n概念\nwebpack 是前端项目工程化的具体解决方案。提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JavaScript 的兼容性、性能优化等强大的功能。让程序员把工作的重心放到具体功能的实现上，提高了前端开发效率和项目的可维护性。\n\n\nwebpack全局安装\nnpm install webpack webpack-cli -D\n\n\nwebpack配置项\n在webpack.config.js中进行配置\n\nwebpack的基本配置项及插件配置\n\n基本配置项\nmode\n\n ① development — 开发环境 \n\n不会对打包生成的文件进行代码压缩和性能优化 \n\n打包速度快，适合在开发阶段使用\n\n ② production ——生产环境 \n\n 会对打包生成的文件进行代码压缩和性能优化 \n\n打包速度很慢，仅适合在项目发布阶段使用\n\n\n\nentry/output\n\n通过 entry 节点指定打包的入口。通过 output 节点指定打包的出口\n\n\n\n\n插件配置项\n1 webpack-dev-server\n\n让 webpack 监听项目源代码的变化，从而进行自动打包构建。\n\n\n2 html-webpack-plugin\n\n通过 html-webpack-plugin 插件，将 src 目录下的 index.html 首页，复制到项目根目录中一份,将页面放入到内存中\n\n\n3 devServer\n\n控制打包后是否自动打开/访问路径/自定义端口号\n\n\n\n\nloader加载\n打包处理css\n\n打包处理less\n\n打包处理路径图片\n\n打包处理高级JS语法\n\n\n\n\n\nSourceMap\n作用：精准定位到错误行并显示对应的源码 方便开发者调试源码中的错误\n\n开发实践\n\n① 开发环境下：\n\n把 devtool 的值设置为 eval-source-map\n\n好处：可以精准定位到具体的错误行\n\n\n\n② 生产环境下：\n\n建议关闭 Source Map 或将 devtool 的值设置为 nosources-source-map\n\n好处：防止源码泄露，提高网站的安全性\n\n\n\n\n\n\n\n\n\n\n","categories":["前端工程化"],"tags":["Webpack"]},{"title":"连等赋值问题","url":"/Interview/interview/20220225-2022-02.html","content":"坐着突然看到一个题，想了一下答错了，看了题解之后还是不太理解，终于在一个大佬的白话中get到卡住的点！\n解答地址：https://segmentfault.com/q/1010000002637728\n1.赋值表达式的概念：计算一般的赋值表达式 A = B按如下步骤：\n\n计算表达式A，得到一个引用refA；\n计算表达式B，得到一个值valueB；\n将valueB赋给refA指向的名称绑定；\n返回valueB。‘\n\n连等的核心思想：连等是先确定所有变量的指针，再让指针指向那个赋值\n对于题1:1 var a = b =10;2      (function()&#123;3          var a = b = 20;4       &#125;)();5 console.log(a);6 console.log(b);//问：输出的 a = ?    b = ?//10 20\n\n\n首先第一行的 var a = b = 10; 就是用了连等操作符，连等操作符是从右向左的 所以类似于b = 10; a = b;或者是 a = (b = 10);\n此时，变量a是用var进行声明并赋值的所以是局部变量，\n但是b是未声明而直接进行赋值的所以是全局变量。\n\n\n第二行开始使用匿名函数实现模仿块级作用于（私有作用域）:在里面声明的变量会在函数结束后被销毁除非被外部所使用\n第三行，先使用外部局部变量b，b =20; 然后又**重新声明了一个变量a**\n此时内部的局部新生成的a为20\n\n\n第四行声明定义一个匿名函数后随即执行，**私有作用域中创建的变量a在结束后随即被销毁**.所以最后改变的只有外部的变量b的值.\n此时b=20 ,a还是为之前外部的10\n\n\n\n对于题2:1 var a = &#123;n: 1&#125;;2 var b = a;3 a.x = a = &#123;n: 2&#125;;4 alert(a.x); // --&gt; 5 alert(b.x); // --&gt; \n\n\n第三行声明变量b，并且把a的对象引用赋值给b。\n\n此时，变量b和a指向的是同一个对象，即他们现在共享。\na:{n:2},b:{n:2}\n\n\n第四行:————连等是先确定所有变量的指针，再让指针指向那个赋值\n\n找到 a 和 a.x 的指针。如果已有指针，那么不改变它。如果没有指针，即那个变量还没被申明，那么就创建它，指向 null。\n此时，a 是有指针的，指向 &#123;n:1&#125;；\na.x 是没有指针的，所以创建它，指向 null。\n\n\n.运算优先于=赋值运算，因此此处赋值可理解为\n声明a对象中的x属性，用于赋值，此时b指向a，同时拥有未赋值的x属性\n对a对象赋值，此时变量名a改变指向到对象{n:2}\n对步骤1中x属性，也即a原指向对象的x属性，也即b指向对象的x属性赋值\n\n\n\n\n上图更明确：\n\n\n\n","categories":["Interview"],"tags":["javascript"]},{"title":"vue基础——特性/指令/过滤器/侦听器/计算属性","url":"/VUE/VUE-study/vue-base-2022-02.html","content":"VUE特性\n① 数据驱动视图：\n\n优点：当页面数据发生变化时，页面会自动重新渲染页面的结构\n\n⚠️注意：数据驱动视图是单向的数据绑定。\n\n\n\n ② 双向数据绑定\n\n优点：不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中\n\n\nMVVM——Model、View 、 ViewModel\n具体结构\n\nModel 表示当前页面渲染时所依赖的数据源。\n\nView 表示当前页面所渲染的 DOM 结构。\n\nViewModel 表示 vue 的实例，它是 MVVM 的核心。\n\n\n\n工作原理\n\n当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构\n\n当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中\n\n\n\nMVVM具体结构的对应关系\n\n\nVUE指令\n① 内容渲染指令\n\nv-text：\n\n放在标签内使用,只渲染纯文本\n\nv-text 指令会覆盖元素内默认的值。\n\n\n\n 插值表达式——&#123;&#123;msg&#125;&#125;\n\n它不会覆盖元素中默认的文本内容，只渲染纯文本\n\n⚠️：除了支持绑定简单的数据值之外，还支持 Javascript 表达式的运算:三元表达式/数字计算/数组修改\n\nv-html\n\n将包含 HTML 标签的字符串渲染为页面的 HTML 元素\n\n\n\n\n② 属性绑定指令——v-bind/：\n\n为元素的属性动态单向绑定属性值\n\n\n③ 事件绑定指令——v-on/@\n\n为 DOM 元素绑定事件监听,eg:：@click、 @input、@keyup\n\n绑定的事件处理函数，需要在 methods 节点中进行声明\n\n常用事件修饰符——@event.事件修饰符\n\n按键修饰符——.enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right\n\n事件对象$event\n\n注意在事件中要使用 $event 符号\n\n获取当前事件元素：e.target\n\n\n\n\n\n④ 双向数据绑定指令——v-model\n\n常用修饰符\n\n\n⑤ 条件渲染指令——v-if/v-show\n\n实现原理\n\nv-if 指令会动态地创建或移除 DOM 元素，从而控制元素在页面上的显示与隐藏, 有更高的切换开销；\n\nv-show 指令会动态为元素添加或移除 style=”display: none;” 样式，从而控制元素的显示与隐藏,更高的初始渲染开销；\n\n\n\n实际使用\n\n如果需要非常频繁地切换——使用 v-show\n\n如果在运行时条件很少改变——使用 v-if\n\n\n\n\n\n⑥ 列表渲染指令——v-for\n\n&lt;tr v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt;&lt;/td&gt;\n\n索引\n\n这里仅仅指的是它当前的位置，而不是绑定的元素/数据\n\nv-for 指令中的 item 项和 index 索引都是形参，可以根据需要进行重命名。例如 (user, i) in userlist\n\n\n\n维护列表的状态——key\n\nkey 的值只能是字符串或数字类型 key 的值必须具有唯一性（即：key 的值不能重复）\n\n建议把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性） \n\n使用 index 的值当作 key 的值没有任何意义（因为 index 的值不具有唯一性）\n\n 建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱）\n\n\n\n\n\n\n文本格式化——过滤器:filters()\n基本用法:\n\n本质上是函数，需定义在fliters下\n\n在过滤器函数中，一定要有 return 值\n\n在html语句中的插值表达式内利用管道符插入相关处理函数： &lt;p&gt;message 的值是：&#123;&#123; message | capi &#125;&#125;&lt;/p&gt;\n\n ⚠️注意：过滤器函数形参可以有其他的参数，但是其默认的第一参数—— val，永远都是“管道符”前面的那个值\n\n\n\n过滤器分类\n\n全局过滤器\n\n具体格式：Vue.filter(&#39;过滤器名称&#39;, function (参数)&#123; &#125; ) \n\n优点：具有复用性\n\n\n\n私有过滤器：直接在vm中调用\n\n\n\n调用原则——就近：如果全局过滤器和私有过滤器名字一致，此时按照“就近原则”，调用的是”私有过滤器“\n\n未完成：完善案例：时间格式化\n\n\n监视数据变化——侦听器:watch:{}\n语法格式:侦听器本质上是一个函数，把数据名作为方法名。新值在前，旧值在后\n\n侦听器格式：\n\n方法格式：\n\n具体格式参考：可以看到将数据dataname作为方法名(newVal)\n\n缺点：\n\n1：无法在刚进入页面的时候，自动触发\n\n2：如果侦听的数据data中是一个对象，如果对象中的属性发生了变化，不会触发侦听器！！！\n\n\n\n\n\n对象格式：\n\n具体格式参考：此时需要一个handler(newVal,oldVal)的处理函数进行传值\n\n优点：\n\n1：侦听器自动触发—— immediate 选项\n\nimmediate为boolean类型，默认为false，如果为true则设置自动触发一次\n\n\n2：侦听器深度监听对象中每个属性的变化—— deep 选项\n\ndeep选项为boolean类型，默认为false，如果为true，只要对象中任何一个属性变化了，都会触发“对象的侦听器”\n\n⚠️注意：如果要单独侦听对象子属性的变化，则必须包裹一层单引号——‘info.username’(newVal) {}\n\n\n\n\n\n\n\n\n\n\n计算属性——computed()\n定义的时候，要被定义为“方法”,但本质是一个属性\n\n具体格式：写在computed:&#123;&#125;中，属性要定义为方法格式\n\n优点：\n\n实现了代码的复用\n\n只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值！\n\n\n\n\n","categories":["VUE"],"tags":["VUE"]},{"title":"Algorithm","url":"/Algorithm/Algorithm/page-2022-03.html","content":"\n数组\n\n创建数组\n\n创造指定长度的空数组:const arr = new Array(数组长度)\n\n创建一个长度确定、同时每一个元素的值也都确定的数组(每个都是1）：const arr = (new Array(7)).fill(1)\n\n\n\n访问:直接在中括号中指定其索引\n\n遍历数组:\n\n如果没有特殊的需要，那么统一使用 for 循环来实现遍历。因为从性能上看，for 循环遍历起来是最快的。\n\nfor 循环\n\nforEach 方法：可以取到数组每个元素的值及其对应索引\n\nmap 方法——返回新数组遍历的基础上“再加工”\n\n\n\n二维数组=矩阵\n\n初始化：for 循环\n\n访问：两遍for循环\n\n\n\n问题：关于二维数组使用fill的局限性\n\n当用const arr =(new Array(7)).fill([])初始化数组时，此时将arr[0][0] = 1会发现一整列元素都会变成1当给 fill 传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用这7个数组对应了同一个引用、指向的是同一块内存空间，它们本质上是同一个数组。因此当你修改第0行第0个元素的值时，第1-6行的第0个元素的值也都会跟着发生改变。\n\n\n灵活增删的数组 \n\n数组增加元素的方法：\n\nunshift 方法-添加元素到数组的头部\n\nunshift 方法-添加元素到数组的头部\n\nsplice 方法-添加元素到数组的任何位置arr.splice(start,数量,item值) // [1,3,2]\n\n\n\n\n\n\n\n\n","categories":["Algorithm"],"tags":["Algorithm-基础笔记"]},{"title":"计算机网络","url":"/interview/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3-2022-03.html","content":"\n知识点：\n进程和线程\n进程：内存中正在运行的应用程序\n\n线程：进程的最小执行单位\n\n浏览器采取了多进程模型（至少4个）\n\n浏览器进程主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。\n\n渲染进程 核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都运行在该进程中，默认情况下，Chrome为每一个Tab标签页创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下的。\n\nGPU进程。GPU图形处理器（英语：graphics processing unit，缩写：GPU）,负责3D css效果，网页，Chrome ui的绘制。\n\n网络进程主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立处理，成为单独一个进程。\n\n插件进程。主要负责插件的运行，因为插件易崩溃，所以通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n\n\n\n\n计算机网络的ISO七层模型\n1、物理层：\n\n使用一定的物理介质(光纤，网线wifi）\n\n\n2、数据链路层：MAC地址 封裝 单位为byte\n\n通过网关进行通信 \n\n\n3、网络层：\n\nIP协议：将数据从主机A发送给主机B，不能保证肯定发送给目标\n\n\n4、传输层：具有端口，确保数据传输\n\nUDP(用户数据包协议）——只管发不管收——DNS\n\nTCP(传输控制协议)：\n\n重传机制\n\n排序机制：将主机A发给B的多个数据包按照编号进行排序进行重组，保证完整性\n\n相关面试题：TCP和UDP区别:面向连接/可靠性/基于字节流/TCP三次握手/TCP四次挥手\n\n\n\n\n\n5、会话层:\n\n断点续传\n\n\n6、表示层——翻译——解决不同系统数据之间传输的问题\n\n7、应用层：#问题\n\nHTTP协议：\n\n\n\n\nHTTP请求流程\n浏览器发送HTTP请求 \n\n1、构造请求行：GET /api/article HTTP/1.1\n\n2、查找缓存：有就去缓存存，没有呢就发选网络请求\n\n3、准备IP地址和端口号\n\n4、 等待TCP队列:因为一个域名最多只能生立6个TCP连接\n\n5、建立TCP连接\n\n6、发送HTTP请求\n\n版本2:\n\n1、先查找缓存，检测缓存是否过期，直接返回缓存中内容\n\n2、看域名是否被解析，DNS协议，DNS协议是基于UPD协议  ip+端口号 \n\n3、ip地址寻址，排队等候，最多发送6个http请求\n\n4、tcp创建链接，用户传输(三次握手)\n\n5、利用tcp传输数据(拆分数据包，有序)  可靠，有序，服务器会按照顺序来接受\n\n6、http请求(请求行，请求头，请求体)\n\n7、默认不会断开keep-alive，为下次传输数据是，可以复用上次的创建的连接\n\n8、服务器接受数据后(响应行 响应头 响应头)\n\n\n\n\n\n\n\n输入url地址到显示的过程\n进程角度：\n\n其他角度\n\n\n\n\n\n常见面试题\n一次完整的http服务过程\n一次完整的http服务的几个阶段\n\nhtml的渲染过程\n\n常见的http请求状态码\n\n\n\n传输层——TCP/UDP相关\nTCP和UDP区别:面向连接/可靠性/基于字节流\nTCP是基于连接的，可靠性高(有状态/可控制/TCP流量控制/TCP拥塞控制)，安全，但是相同数据下开销大；只支持点到点连接，面向字节流\n\n有状态；TCP会精准记录哪些数据发送了，被对方接受了，哪些没有，而保证数据按序到达，不允许差错 \n\n可控制；意识到丢包或者网络环境差，TCP根据具体情况调整自己的行为，控制自己发送速度或重发\n\n\n\nUDP是基于无连接的，可靠性较低，实时性高，会存在丢包问题，支持多种连接方式\n\n应用场景的区别：\n\n如果对实时性要求高和高速传输/可靠性要求低追求效率的场景下需要使用UDP；\n\n如果需要传输大量数据且对数据可靠性要求高的场景使用TCP；\n\n\n\n\n\nTCP三次握手\n握手过程：确认双方的两样能力: 发送的能力和接收的能力\n\n1.最开始双方都属于CLOSED状态。然后服务器开始监听某个端口，进入LISTEN状态。\n\n2.客户端注重发起连接，发送SYN，自己变成了SYN-SENT状态\n\n3.服务端收到，返回SYN和ACK（对应客户端发来的SYN），自己变成了SYN-REVD\n\n4.客户端再发送ACK给服务端，自己变成ESTABLISHED（established）状态；服务端收到ACK之后，也变成这个状态\n\n#注意：SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1凡是需要对端确认的，一定消耗TCP报文的序列号。\n\n\n\n为什么不是两次？\n\n两次握手只能确定从 客户端 到 服务端 的网络是可达的，但却无法保证从 服务端 到 客户端 的网络是可达的。第三次握手就是为了确定从 服务端 到 客户端 的网络是否可达，两次握手，服务端只要接收到然后发送相应的数据包，就 默认连接 了 ，但是事实上现在客户端可能已经断开连接了，这样也就带来了连接资源的浪费 \n\n\n为什么不是四次？\n\n当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。\n\n\n三次握手过程中可以携带数据么？\n\n可以，但是只有第三次，此时的established状态相对安全并且够确认服务器的接收发送能力。而不能在第一次握手携带数据是为了防止黑客在syn中放入大量数据造成服务器资源的消耗。\n\n\n\n\nTCP四次挥手\n过程\n\n首先客户端主动关闭，向服务器发FIN报文\n\n服务端接收后通知应用进程并向客户端发送ACK确认\n\n服务端处理完后被动关闭再次向客户端发送FIN以及ACK，进入LAST-ACK状态，\n\n客户端收到服务端发来的FIN后，发送 ACK 给服务端。在等待2MSL后进入CLOSED状态\n\n\n\n#问题 为什么要等待2MSL（最长报文段寿命）\n如果客户端没有收到服务端的重发请求，表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。\n\n1 个 MSL 确保四次挥手中第四步的ACK可以准确到达\n\n1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达\n\n如果不等待：当服务端还有很多数据包要给客户端发，此时客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。\n\n\n\n为什么不是三次？\n\n如果三次，服务端将ACK和FIN的发送合并为一次挥手，这个时候为了传递没有完成的数据，长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。\n\n因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。\n\n\n\n\n\nSYN Flood 攻击原理\n原理:典型的 DoS/DDoS 攻击。用客户端在短时间内伪造大量不存在的 IP地址，并向服务端疯狂发送SYN。\n\n处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。\n\n由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。\n\n\n\n应对方法: \n\n增加 SYN 连接，也就是增加半连接队列的容量。\n\n减少 SYN + ACK 重试次数，避免大量的超时重发。\n\n利用 SYN Cookie技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证Cookie 合法之后才分配连接资源。\n\n\n\n\n\nTCP 短连接和长连接的区别\n短连接：\n\nClient 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。\n\n优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。\n\n\n\n长连接：\n\nClient 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。\n\n应对策略：\n\n关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；\n\n以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。\n\n\n\n\n\n\n\nTCP可靠性特质\nTCP流量控制\n\nTCP拥塞控制\n\n\n\n粘包拆包问题（消息边界问题）\n场景\n假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。\n\n成功结果：服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；\n\n失败1：服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；\n\n失败2：服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；\n\n失败3：服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。\n\n\n\n如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。\n\n\n\n\n\n应用层-HTTP、HTPS、DNS\nHTTP的特点？它有什么缺点？\n\nHTTP请求报文\n\nHTTP响应报文\n\n\n\n\n\n\n","categories":["interview"],"tags":["interview"]}]