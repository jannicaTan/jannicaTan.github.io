[{"title":"JavaScript-运算符：短路运算/赋值运算","url":"/JavaScript/JS-study/%E8%BF%90%E7%AE%97%E7%AC%A6-2021-12.html","content":"1.短路运算(逻辑中断)原理： 当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值\n①逻辑与语法：表达式1 &amp;&amp; 表达式2\n如果第一个表达式的值为真，则返回表达式2\n如果第一个表达式的值为假，则返回表达式1\nconsole.log(123 &amp;&amp; 456);   //456console.log(0 &amp;&amp; 456);     //0console.log(123 &amp;&amp; 456 &amp;&amp; 789);  //789\n\n②逻辑或语法：表达式1 || 表达式2\n如果第一个表达式的值为真，则返回表达式1\n如果第一个表达式的值为假，则返回表达式2 21302004高校实验室安全基础（通识B）.pdf \nconsole.log(123 || 456); //123console.log(0 || 456);   //456console.log(123 || 456 || 789);  //123\n\nvar num = 0;console.log(123 || num++);// 先返回在加，相当于 (123 || 0)console.log(num);    // 123\n\n2.赋值运算符概念： 用来把数据赋值给变量的运算符。\n\n\n\n赋值运算符\n说明\n案例\n\n\n\n=\n直接赋值\nvar usrName = ‘我是值’\n\n\n+= ，-=\n加，减一个数后再赋值\nvar age = 10； age+=5；//15\n\n\n*=，/=，%=\n成，除，取模后再赋值\nvar age = 2; age*=5; //10\n\n\nvar age = 10;age += 5;  // 相当于 age = age + 5;age -= 5;  // 相当于 age = age - 5;age *= 10; // 相当于 age = age * 10;\n\n","categories":["JavaScript"],"tags":["JS基础语法"]},{"title":"关于配置hexo的坑及解决办法","url":"/Hexo/hexo/mis_config_hexo-2021-12.html","content":"最近在学习配置hexo，遇到了一些安装坑，去搜解决方式还遇到了网上不负责任的回答。于是决定还是记录下来 再有人和我一样的情况也不用抓耳挠腮了 \n本文只针对我遇到的问题和解决方式 如有不对还请指出 \n环境及主题：我使用的hexo+Github的配合\n主题:keep主题,很推荐 整个的配置教程很清晰\n这里放上github地址：https://github.com/XPoet/hexo-theme-keep\n1.关于指令：keep g: 生成文件\nkeep deploy: 部署文件\nkeep s:可以在本地预览修改后的样子 \n在正式提交前 可以在本地预览到满意再提交！不用一遍遍的提交去线上查看！！\n2.关于修改背景图片，部署到线上后，显示空白首先打开开发者模式，在控制台查看是否图片报错，如果报错，多半是url出问题了,返回主题的配置文件中修改你的url就可以了\n3.关于keep主题分类/标签创建后，不能正确显示分类及个数3.1生成“分类”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令\n$ hexo new page categories\n\n找到source/categories/index.md这个文件，添加type: &quot;categories&quot;到内容中：\n---title: category //这里注意一定要与themes/keep/layout/page.ejs中的关于分类的title一致date: 2021-12-21 18:07:36type: &quot;categories&quot;---\n\n保存并关闭文件。\n❗️关于不能正确显示分类及个数检查两点❗️\n\nkeep主题：\n检查这里的title名是否与themes/keep/layout/page.ejs中的关于分类的title一致：应为category或者categories\n\n\n非keep主题:\n找到主题对应的themes/keep/layout/再其下方文件中找到关于分类的xxx.ejs文件复制文件名，返回source/categories/index.md添加一行layout: xxx.ejs即可\n\n\n\n3.2 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。\n---title: 文章标题date: XXXXXcategories: 文章对应的分类（自拟）---\n\n⚠️注意：只有添加了categories: xxx的文章才会被收录到首页的“分类”中。\n4.关于hexo多终端同步的问题我找到两个方法，目前我使用的是第一种，这两种方法的解答都将多终端解释的比较清楚，可以自行选择\n\nhttps://www.jianshu.com/p/fceaf373d797\nhttps://www.zhihu.com/question/21193762\n直上云霄的回答\nhttp://fangzh.top/2018/2018090715/\n\n\n\n5.未待完续","categories":["Hexo"],"tags":["Hexo"]},{"title":"DOM-Day1-DOM元素","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM_Day1-2022-01.html","content":"- DOM简介- DOM树\n\n文档：document\n标签：element\n节点-内容：node 标签/属性/文本/注释等\n\n\n- 获取元素- 根据ID获取——getElementById\n参数\n**element**是一个 Element 对象。如果当前文档中拥有特定ID的元素不存在则返回null.\n**id**是大小写敏感的字符串，代表了所要查找的元素的唯一ID.\n\n\n返回值\n返回一个匹配到 ID 的 DOM Element 对象。若在当前 Document 下没有找到，则返回 null。\n\n\n\n- 根据tag获取——getElementsByTagName(标签名)&lt;script&gt;    // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的    var lis = document.getElementsByTagName(&#x27;li&#x27;);    console.log(lis);    console.log(lis[0]);    // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式,动态变化    for (var i = 0; i &lt; lis.length; i++) &#123;        console.log(lis[i]);    &#125;    // 3. 如果页面中只有一个li 返回的还是伪数组的形式     // 4. 如果页面中没有这个元素 返回的是空的伪数组的形式    // 5. element.getElementsByTagName(&#x27;标签名&#x27;); //    父元素必须是指定的单个元素,不能用伪数组形式作为父元素//    获取的时候不包括父元素本身    // var ol = document.getElementsByTagName(&#x27;ol&#x27;); // [ol]    // console.log(ol[0].getElementsByTagName(&#x27;li&#x27;));    var ol = document.getElementById(&#x27;ol&#x27;);    console.log(ol.getElementsByTagName(&#x27;li&#x27;));&lt;/script&gt;\n\n- H5新增，不能兼容IE6/7/8的方法- 通过类选择器获取元素——getElementByClassName()//根据类名获得某些元素集合        var boxs = document.getElementsByClassName(&#x27;box&#x27;);        console.log(boxs);\n\n- 通过选择器获取元素querySelector()返回指定选择器的第一个元素对象  \nquerySelectorAll()返回指定选择器的所有元素对象集合\n⚠️里面的选择器需要加符号\n\nclass-&gt;’.box’ \n id-&gt;’#nav’\n\nvar firstBox = document.querySelector(&#x27;.box&#x27;);console.log(firstBox);var allBox = document.querySelectorAll(&#x27;.box&#x27;);console.log(allBox);var nav = document.querySelector(&#x27;#nav&#x27;);console.log(nav);var li = document.querySelector(&#x27;li&#x27;);console.log(li);\n\n- 获取特殊元素获取body——document.body\n获取html——document.documentElement\n\n- 事件基础- 事件三要素：事件源、事件类型和事件处理程序。(1)事件源：事件被触发的对象，例如按钮(2)事件类型：如何触发，例如鼠标点击(onclick)(3)事件处理程序：通过一个函数赋值的方式完成\n&lt;button id=&#x27;btn1&#x27;&gt;1+1&lt;/button&gt;&lt;script&gt;    var btn1 =document.querySelector(&#x27;#btn1&#x27;);    btn1.onclick=function()&#123;        alert(&#x27;2&#x27;);    &#125;&lt;/script&gt;\n\n\n\n获得焦点事件——onfocus \n失去焦点事件——onblur\n\n3.2执行事件三步骤：// 1. 获取事件源var div = document.querySelector(&#x27;div&#x27;);// 2.绑定事件 注册事件// div.onclick // 3.添加事件处理程序 div.onclick = function() &#123;    console.log(&#x27;我被选中了&#x27;);&#125;\n\n\n- 操作元素- 改变元素内容——innerText()/innerHTML()- innerText 和 innerHTML的区别\n\n\ninnerText\ninnerHTML\n\n\n\n不识别html标签 非标准\n识别html标签 W3C标准\n\n\n这两个属性是可读写的  可以获取元素里面的内容\n\n\n\n去除空格和换行\n保留空格和换行\n\n\n- 修改元素- 表单input属性修改常用属性：type/value/checked/selected/disabled\n不可以用innerHTML了\n- 样式属性操作——element.style/className我们可以通过 JS 修改元素的大小、颜色、位置等样式。\n\n行内样式：element.style，样式修改较少\n类名样式：element.className，样式修改较多\n\n⚠️注意：1.JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor \n2.JS 修改 style 样式操作，产生的是行内样式，权重比较高\n\n总结\n","categories":["DOM学习"],"tags":["DOM学习-day1"]},{"title":"DOM-day3-DOM操作重点","url":"/uncategorized/DOM-study/DOM-day3-2022-01.html","content":"三种动态创建元素区别-经典面试题document.write()element.innerHTMLdocument.createElement()DOM重点核心DOM操作创建——3个增加——2个删除——1个修改\n修改元素属性:\n修改元素内容:\n修改表单元素:\n修改元素样式:\n\n查——3类\nDOM API\nH5 新方法：\n利用节点操作获取元素:\n\n属性操作——自定义属性\n设置\nelement.getAttribute()\n\n获取\n\n移除\n\n\n事件操作","tags":["DOM学习-day3"]},{"title":"DOM_day2-自定义属性/节点操作","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM-day2-2022-01.html","content":"排他思想：主要做法：1.所有元素清除样式，使用for循环\n2.给当前元素设置样式，使用this\n实例：\n百度换肤\n表格变色\n表格全选/反选\n\n自定义属性操作：获取元素的属性值(1) element.属性——获取元素本身自带的内置属性\n(2) element.getAttribute(&#39;属性&#39;)——获取自定义属性\n​     get得到获取 attribute 属性的意思，我们程序员自己添加的属性我们称为自定义属性 index\n设置元素的属性值 (1) element.属性= &#39;值&#39;——直接赋值\ndiv.id = &#x27;test&#x27;;div.className = &#x27;navs&#x27;;\n\n (2) element.setAttribute(&#39;属性&#39;, &#39;值&#39;)——针对于自定义属性\ndiv.setAttribute(&#x27;index&#x27;, 2);\n\n移除属性——removeAttribute(属性)div.removeAttribute(&#x27;index&#x27;);\n\n实例：\nTab栏切换\n\nH5自定义属性命名——data-开头dataset——存放了所有以data开头的自定义属性dataset是一个集合，里面存放了所有以data开头的自定义属性，获取其中属性的操作如下：\n⚠️：\n\n如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法\nIE11以上才可应用，兼容性不好\n\nconsole.log(div.dataset);console.log(div.dataset.index);console.log(div.dataset[&#x27;index&#x27;]);\n\n节点操作:一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性\n\n元素节点nodeType 为1\n属性节点nodeType 为2\n文本节点noueType 为多（文本节点包含文字、全修、接行等）\n\n","categories":["DOM学习"],"tags":["DOM学习-day2"]},{"title":"DOM-day4-DOM高级事件","url":"/uncategorized/DOM-study/DOM-day4-2022-01.html","content":"元素注册事件的两种方式1.传统注册事件——on开头特点:注册时间具有唯一性 同一个元素的同一事件只能设置一个处理函数\n2.事件侦听注册事件——addEventListener(&#39;事件类型&#39;,function()&#123;&#125;,useCapture(true/false))特点:\n (1) 里面的事件类型是字符串 必定加引号 而且不带on\n (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）按顺序执行\n删除事件的两种方式1.传统删除事件——元素名.事件类型=null2.常用——元素名.removeEventListener(&#39;事件类型&#39;,注册事件方法名)3.IE9以下老版本——元素名.detachListener(&#39;事件类型&#39;,注册事件方法名)DOM 事件流的三个阶段三个阶段 捕获阶段-&gt;当前目标阶段-&gt;冒泡阶段1.捕获阶段: addEventListener 第三个参数是 true\n顺着从大到小：document -&gt; html -&gt; body -&gt; father -&gt; son \n点击相应,其他元素没有这个动作 则点击其他元素不会反应,依次向下寻找\n2.冒泡阶段: addEventListener 第三个参数是 false/省略\n顺着从小到大去找点击响应：son -&gt; father -&gt;body -&gt; html -&gt; document\n事件对象——event事件\nevent 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看\n\n事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数\n\n事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的,\n​    比如鼠标点击里面就包含了鼠标的相关信息：鼠标坐标\n​    如果是键盘事件里面就包含的键盘事件的信息：判断用户按下了那个键\n\n这个事件对象我们可以自己命名 比如 event 、 evt、 e\n\n事件对象也有兼容性问题 ie678 \n通过 window.event 兼容性的写法  e = e || window.event;\n\n\nvar div = document.querySelector(&#x27;div&#x27;);div.addEventListener(&#x27;click&#x27;, function(e) &#123;  console.log(e);&#125;)\n\n常见事件对象的属性和方法1.e.target——返回的是触发事件的对象（元素）与this的区别：\n\ne.target 点击了那个元素，就返回那个元素\nthis 哪个元素绑定了这个点击事件，那么就返回绑定该事件的元素\ne.srcElement:适用于低版本:IE6/7/8\n\nvar ul = document.querySelector(&#x27;ul&#x27;);ul.addEventListener(&#x27;click&#x27;, function(e) &#123;  // 我们给ul 绑定了事件  那么this 就指向ul    console.log(this);//ul  // e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target 指向的就是li  console.log(e.target);//li  console.log(e.currentTarget);            &#125;)\n\n2.e.type——返回当前触发的事件类型3.e.preventDefault()——阻止默认行为(事件)实例：\n\n点击超链接不跳转\n点击提交按钮不提交\n\n4.重点：e.stopPropagation()——阻止冒泡防止在底层事件触发上层事件\n事件委托**原理**：给父节点添加侦听器，而不给每个子节点单独设置监听器，利用事件冒泡传到父节点，影响每一个子节点\n**作用**：只操作了一次DOM，提高了效率\n**实例**：为父节点添加操作，用e.target.具体元素内容识别每次操作的子节点\nvar ul=document.querySelector(&#x27;ul&#x27;);ul.addEventListener(&#x27;click&#x27;,function(e)&#123;  e.target.style.backgroundColor=&#x27;pink&#x27;&#125;)\n\n鼠标事件对象——MouseEvent进行相应的鼠标操作事件(click/onmouseover/onmouseout)后返回对应的坐标位置\n1.e.clientX/e.clientY——可视区坐标2.e.pageX/e.pageY——页面文档坐标(滚动页面)滚动页面坐标也会变化的\n3.e.screenX/e.screenY——电脑屏幕坐标**案例**：跟随鼠标的图标操作\n键盘事件进行相应的键盘操作所反馈的信息，执行顺序为:keydown-&gt;keypress-&gt;keyup\n1.keyup——**按下按键弹起后**触发\n2.keypress——按下按键即触发:无法识别功能键\n3.keydown——按下按键即触发:识别功能键\n键盘对象——keyCode激发键盘事件后可以得到相应键的 ASCII码值\n**注意**：\n\n我们的keyup 和keydown事件不区分字母大小写  a 和 A 得到的都是65\n\n我们的keypress 事件,区分字母大小写  a  97 和 A 得到的是65\n\n\n","tags":["DOM学习-day4"]}]