[{"title":"JavaScript-运算符：短路运算/赋值运算","url":"/JavaScript/JS-study/%E8%BF%90%E7%AE%97%E7%AC%A6-2021-12.html","content":"1.短路运算(逻辑中断)原理： 当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值\n①逻辑与语法：表达式1 &amp;&amp; 表达式2\n如果第一个表达式的值为真，则返回表达式2\n如果第一个表达式的值为假，则返回表达式1\nconsole.log(123 &amp;&amp; 456);   //456console.log(0 &amp;&amp; 456);     //0console.log(123 &amp;&amp; 456 &amp;&amp; 789);  //789\n\n②逻辑或语法：表达式1 || 表达式2\n如果第一个表达式的值为真，则返回表达式1\n如果第一个表达式的值为假，则返回表达式2 21302004高校实验室安全基础（通识B）.pdf \nconsole.log(123 || 456); //123console.log(0 || 456);   //456console.log(123 || 456 || 789);  //123\n\nvar num = 0;console.log(123 || num++);// 先返回在加，相当于 (123 || 0)console.log(num);    // 123\n\n2.赋值运算符概念： 用来把数据赋值给变量的运算符。\n\n\n\n赋值运算符\n说明\n案例\n\n\n\n=\n直接赋值\nvar usrName = ‘我是值’\n\n\n+= ，-=\n加，减一个数后再赋值\nvar age = 10； age+=5；//15\n\n\n*=，/=，%=\n成，除，取模后再赋值\nvar age = 2; age*=5; //10\n\n\nvar age = 10;age += 5;  // 相当于 age = age + 5;age -= 5;  // 相当于 age = age - 5;age *= 10; // 相当于 age = age * 10;\n\n","categories":["JavaScript"],"tags":["JS基础语法"]},{"title":"关于配置hexo的坑及解决办法","url":"/Hexo/hexo/mis_config_hexo-2021-12.html","content":"最近在学习配置hexo，遇到了一些安装坑，去搜解决方式还遇到了网上不负责任的回答。于是决定还是记录下来 再有人和我一样的情况也不用抓耳挠腮了 \n本文只针对我遇到的问题和解决方式 如有不对还请指出 \n环境及主题：我使用的hexo+Github的配合\n主题:keep主题,很推荐 整个的配置教程很清晰\n这里放上github地址：https://github.com/XPoet/hexo-theme-keep\n1.关于指令：keep g: 生成文件\nkeep deploy: 部署文件\nkeep s:可以在本地预览修改后的样子 \n在正式提交前 可以在本地预览到满意再提交！不用一遍遍的提交去线上查看！！\n2.关于修改背景图片，部署到线上后，显示空白首先打开开发者模式，在控制台查看是否图片报错，如果报错，多半是url出问题了,返回主题的配置文件中修改你的url就可以了\n3.关于keep主题分类/标签创建后，不能正确显示分类及个数3.1生成“分类”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令\n$ hexo new page categories\n\n找到source/categories/index.md这个文件，添加type: &quot;categories&quot;到内容中：\n---title: category //这里注意一定要与themes/keep/layout/page.ejs中的关于分类的title一致date: 2021-12-21 18:07:36type: &quot;categories&quot;---\n\n保存并关闭文件。\n❗️关于不能正确显示分类及个数检查两点❗️\n\nkeep主题：\n检查这里的title名是否与themes/keep/layout/page.ejs中的关于分类的title一致：应为category或者categories\n\n\n非keep主题:\n找到主题对应的themes/keep/layout/再其下方文件中找到关于分类的xxx.ejs文件复制文件名，返回source/categories/index.md添加一行layout: xxx.ejs即可\n\n\n\n3.2 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。\n---title: 文章标题date: XXXXXcategories: 文章对应的分类（自拟）---\n\n⚠️注意：只有添加了categories: xxx的文章才会被收录到首页的“分类”中。\n4.关于hexo多终端同步的问题我找到两个方法，目前我使用的是第一种，这两种方法的解答都将多终端解释的比较清楚，可以自行选择\n\nhttps://www.jianshu.com/p/fceaf373d797\nhttps://www.zhihu.com/question/21193762\n直上云霄的回答\nhttp://fangzh.top/2018/2018090715/\n\n\n\n5.未待完续","categories":["Hexo"],"tags":["Hexo"]},{"title":"DOM-Day1-DOM元素","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM_Day1-2022-01.html","content":"- DOM简介- DOM树\n\n文档：document\n标签：element\n节点-内容：node 标签/属性/文本/注释等\n\n\n- 获取元素- 根据ID获取——getElementById\n参数\n**element**是一个 Element 对象。如果当前文档中拥有特定ID的元素不存在则返回null.\n**id**是大小写敏感的字符串，代表了所要查找的元素的唯一ID.\n\n\n返回值\n返回一个匹配到 ID 的 DOM Element 对象。若在当前 Document 下没有找到，则返回 null。\n\n\n\n- 根据tag获取——getElementsByTagName(标签名)&lt;script&gt;    // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的    var lis = document.getElementsByTagName(&#x27;li&#x27;);    console.log(lis);    console.log(lis[0]);    // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式,动态变化    for (var i = 0; i &lt; lis.length; i++) &#123;        console.log(lis[i]);    &#125;    // 3. 如果页面中只有一个li 返回的还是伪数组的形式     // 4. 如果页面中没有这个元素 返回的是空的伪数组的形式    // 5. element.getElementsByTagName(&#x27;标签名&#x27;); //    父元素必须是指定的单个元素,不能用伪数组形式作为父元素//    获取的时候不包括父元素本身    // var ol = document.getElementsByTagName(&#x27;ol&#x27;); // [ol]    // console.log(ol[0].getElementsByTagName(&#x27;li&#x27;));    var ol = document.getElementById(&#x27;ol&#x27;);    console.log(ol.getElementsByTagName(&#x27;li&#x27;));&lt;/script&gt;\n\n- H5新增，不能兼容IE6/7/8的方法- 通过类选择器获取元素——getElementByClassName()//根据类名获得某些元素集合        var boxs = document.getElementsByClassName(&#x27;box&#x27;);        console.log(boxs);\n\n- 通过选择器获取元素querySelector()返回指定选择器的第一个元素对象  \nquerySelectorAll()返回指定选择器的所有元素对象集合\n⚠️里面的选择器需要加符号\n\nclass-&gt;’.box’ \n id-&gt;’#nav’\n\nvar firstBox = document.querySelector(&#x27;.box&#x27;);console.log(firstBox);var allBox = document.querySelectorAll(&#x27;.box&#x27;);console.log(allBox);var nav = document.querySelector(&#x27;#nav&#x27;);console.log(nav);var li = document.querySelector(&#x27;li&#x27;);console.log(li);\n\n- 获取特殊元素获取body——document.body\n获取html——document.documentElement\n\n- 事件基础- 事件三要素：事件源、事件类型和事件处理程序。(1)事件源：事件被触发的对象，例如按钮(2)事件类型：如何触发，例如鼠标点击(onclick)(3)事件处理程序：通过一个函数赋值的方式完成\n&lt;button id=&#x27;btn1&#x27;&gt;1+1&lt;/button&gt;&lt;script&gt;    var btn1 =document.querySelector(&#x27;#btn1&#x27;);    btn1.onclick=function()&#123;        alert(&#x27;2&#x27;);    &#125;&lt;/script&gt;\n\n\n\n获得焦点事件——onfocus \n失去焦点事件——onblur\n\n执行事件三步骤：// 1. 获取事件源var div = document.querySelector(&#x27;div&#x27;);// 2.绑定事件 注册事件// div.onclick // 3.添加事件处理程序 div.onclick = function() &#123;    console.log(&#x27;我被选中了&#x27;);&#125;\n\n\n- 操作元素- 改变元素内容——innerText()/innerHTML()- innerText 和 innerHTML的区别\n\n\ninnerText\ninnerHTML\n\n\n\n不识别html标签 非标准\n识别html标签 W3C标准\n\n\n这两个属性是可读写的  可以获取元素里面的内容\n\n\n\n去除空格和换行\n保留空格和换行\n\n\n- 修改元素- 表单input属性修改常用属性：type/value/checked/selected/disabled\n不可以用innerHTML了\n- 样式属性操作——element.style/className我们可以通过 JS 修改元素的大小、颜色、位置等样式。\n\n行内样式：element.style，样式修改较少\n类名样式：element.className，样式修改较多\n\n⚠️注意：1.JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor \n2.JS 修改 style 样式操作，产生的是行内样式，权重比较高\n\n总结\n","categories":["DOM学习"],"tags":["DOM学习-day1"]},{"title":"DOM-day3-DOM操作重点","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM-day3-2022-01.html","content":"三种动态创建元素区别-经典面试题document.write()element.innerHTMLdocument.createElement()DOM重点核心DOM操作创建——3个增加——2个删除——1个修改\n修改元素属性:\n修改元素内容:\n修改表单元素:\n修改元素样式:\n\n查——3类\nDOM API\nH5 新方法：\n利用节点操作获取元素:\n\n属性操作——自定义属性\n设置\nelement.getAttribute()\n\n获取\n\n移除\n\n\n事件操作","categories":["DOM学习"],"tags":["DOM学习-day3"]},{"title":"DOM_day2-自定义属性/节点操作","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM-day2-2022-01.html","content":"排他思想：主要做法：1.所有元素清除样式，使用for循环\n2.给当前元素设置样式，使用this\n实例：\n百度换肤\n表格变色\n表格全选/反选\n\n自定义属性操作：获取元素的属性值(1) element.属性——获取元素本身自带的内置属性\n(2) element.getAttribute(&#39;属性&#39;)——获取自定义属性\n​     get得到获取 attribute 属性的意思，我们程序员自己添加的属性我们称为自定义属性 index\n设置元素的属性值 (1) element.属性= &#39;值&#39;——直接赋值\ndiv.id = &#x27;test&#x27;;div.className = &#x27;navs&#x27;;\n\n (2) element.setAttribute(&#39;属性&#39;, &#39;值&#39;)——针对于自定义属性\ndiv.setAttribute(&#x27;index&#x27;, 2);\n\n移除属性——removeAttribute(属性)div.removeAttribute(&#x27;index&#x27;);\n\n实例：\nTab栏切换\n\nH5自定义属性命名——data-开头dataset——存放了所有以data开头的自定义属性dataset是一个集合，里面存放了所有以data开头的自定义属性，获取其中属性的操作如下：\n⚠️：\n\n如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法\nIE11以上才可应用，兼容性不好\n\nconsole.log(div.dataset);console.log(div.dataset.index);console.log(div.dataset[&#x27;index&#x27;]);\n\n节点操作:一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性\n\n元素节点nodeType 为1\n属性节点nodeType 为2\n文本节点noueType 为多（文本节点包含文字、全修、接行等）\n\n","categories":["DOM学习"],"tags":["DOM学习-day2"]},{"title":"DOM-day4-DOM高级事件","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM-day4-2022-01.html","content":"元素注册事件的两种方式1.传统注册事件——on开头特点:注册时间具有唯一性 同一个元素的同一事件只能设置一个处理函数\n2.事件侦听注册事件——addEventListener(&#39;事件类型&#39;,function()&#123;&#125;,useCapture(true/false))特点:\n (1) 里面的事件类型是字符串 必定加引号 而且不带on\n (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）按顺序执行\n删除事件的两种方式1.传统删除事件——元素名.事件类型=null2.常用——元素名.removeEventListener(&#39;事件类型&#39;,注册事件方法名)3.IE9以下老版本——元素名.detachListener(&#39;事件类型&#39;,注册事件方法名)DOM 事件流的三个阶段三个阶段 捕获阶段-&gt;当前目标阶段-&gt;冒泡阶段1.捕获阶段: addEventListener 第三个参数是 true\n顺着从大到小：document -&gt; html -&gt; body -&gt; father -&gt; son \n点击相应,其他元素没有这个动作 则点击其他元素不会反应,依次向下寻找\n2.冒泡阶段: addEventListener 第三个参数是 false/省略\n顺着从小到大去找点击响应：son -&gt; father -&gt;body -&gt; html -&gt; document\n事件对象——event事件\nevent 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看\n\n事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数\n\n事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的,\n​    比如鼠标点击里面就包含了鼠标的相关信息：鼠标坐标\n​    如果是键盘事件里面就包含的键盘事件的信息：判断用户按下了那个键\n\n这个事件对象我们可以自己命名 比如 event 、 evt、 e\n\n事件对象也有兼容性问题 ie678 \n通过 window.event 兼容性的写法  e = e || window.event;\n\n\nvar div = document.querySelector(&#x27;div&#x27;);div.addEventListener(&#x27;click&#x27;, function(e) &#123;  console.log(e);&#125;)\n\n常见事件对象的属性和方法1.e.target——返回的是触发事件的对象（元素）与this的区别：\n\ne.target 点击了那个元素，就返回那个元素\nthis 哪个元素绑定了这个点击事件，那么就返回绑定该事件的元素\ne.srcElement:适用于低版本:IE6/7/8\n\nvar ul = document.querySelector(&#x27;ul&#x27;);ul.addEventListener(&#x27;click&#x27;, function(e) &#123;  // 我们给ul 绑定了事件  那么this 就指向ul    console.log(this);//ul  // e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target 指向的就是li  console.log(e.target);//li  console.log(e.currentTarget);            &#125;)\n\n2.e.type——返回当前触发的事件类型3.e.preventDefault()——阻止默认行为(事件)实例：\n\n点击超链接不跳转\n点击提交按钮不提交\n\n4.重点：e.stopPropagation()——阻止冒泡防止在底层事件触发上层事件\n事件委托**原理**：给父节点添加侦听器，而不给每个子节点单独设置监听器，利用事件冒泡传到父节点，影响每一个子节点\n**作用**：只操作了一次DOM，提高了效率\n**实例**：为父节点添加操作，用e.target.具体元素内容识别每次操作的子节点\nvar ul=document.querySelector(&#x27;ul&#x27;);ul.addEventListener(&#x27;click&#x27;,function(e)&#123;  e.target.style.backgroundColor=&#x27;pink&#x27;&#125;)\n\n鼠标事件对象——MouseEvent进行相应的鼠标操作事件(click/onmouseover/onmouseout)后返回对应的坐标位置\n1.e.clientX/e.clientY——可视区坐标2.e.pageX/e.pageY——页面文档坐标(滚动页面)滚动页面坐标也会变化的\n3.e.screenX/e.screenY——电脑屏幕坐标**案例**：跟随鼠标的图标操作\n键盘事件进行相应的键盘操作所反馈的信息，执行顺序为:keydown-&gt;keypress-&gt;keyup\n1.keyup——**按下按键弹起后**触发\n2.keypress——按下按键即触发:无法识别功能键\n3.keydown——按下按键即触发:识别功能键\n键盘对象——keyCode激发键盘事件后可以得到相应键的 ASCII码值\n**注意**：\n\n我们的keyup 和keydown事件不区分字母大小写  a 和 A 得到的都是65\n\n我们的keypress 事件,区分字母大小写  a  97 和 A 得到的是65\n\n\n","categories":["DOM学习"],"tags":["DOM学习-day4"]},{"title":"DOM-day5：PC端网页特效","url":"/DOM%E5%AD%A6%E4%B9%A0/DOM-study/DOM-day5-2022-01.html","content":"- 常见 offset 属性的作用——偏移量- 常见 client 属性的作用- 常见 scroll 属性的作用- 三大系列总结：\noffset系列经常用于获得元素位置 offsetLeft offsetTop\nclient经常用于获取元素大小 clientWidth cientHeighe\nscroll 经常用于获取滚动距商 scrolltop scrolileft\n\n⚠️注意：页面滚动的距商通过 window.page xozfset 获得\n- mouseenter/mouseover区别- 封装简单动画函数- 写出网页轮播图案例","categories":["DOM学习"],"tags":["DOM学习-day4"]},{"title":"ES6-01-初始化","url":"/ES6/VUE-study/vue-start-01-2022-02.html","content":"1.ES6初始化1.1 模块化ES6(node version&gt;14.15.1)\n\n快速初始化包管理配置文件\n\nnpm init -p\n\n\n生成package.json文件\n在其中添加\n\n&quot;type&quot;: module\n\n1.2 ES6模块化基本语法\n\n默认导出与默认导入\n\n默认导出\n\n```jsexport default {导出对象}  - 目的:挂载使外界能够访问导出的对象  - ⚠️注意：只允许使用唯一的一次export default- 默认导入  - ```js    import 自定义变量名称 from ‘模块标识符/文件路径.js’\n\n\n\n\n直接导入\n\n导入的时候直接import js文件路径 即可\n\n\n按需导入与导出\n\n按需导出\n\nexport 导出的变量\n\n\n\n\n按需导入\n\nimport {按需导出的对应名称1,名称2….} from 对应js文件\n\n\n⚠️ 注意事项：\n  1.可以多次按需导出\n  2.按需导入的名称要与按需导出的名称保持一致\n  3.可以使用as 重命名名称 进行重命名\n  4.按需导入可以与默认导入一起\n\n\n\n\n","categories":["ES6"],"tags":["ES6"]},{"title":"ES6-02-Promise/aysnc","url":"/ES6/VUE-study/vue-start-02-2022-02.html","content":"关于读取文件1.then-fs第三方包\nnpm install then-fsimport thenFs from then-fs\n\n2.fs自带包\nimport fs from fs\n\nPromise\nPromise是一个构造函数\n\nPromise中catch用法Promise.all()Promise.race()","categories":["ES6"],"tags":["Promise"]},{"title":"ES6-EventLoop/宏任务和微任务","url":"/ES6/VUE-study/vue-start-03-2022-02.html","content":"同步任务和异步任务的执行顺序JS执行顺序\nJS任务分类\n微任务与宏任务的执行顺序\n","categories":["ES6"],"tags":["EventLoop"]},{"title":"Webpack基础配置(待继续更新)","url":"/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/VUE-study/webpack%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE-2022-02.html","content":"\n\n前端工程化\n模块化\njs 的模块化、css 的模块化、资源的模块化\n\n\n组件化\n复用现有的 UI 结构、样式、行为\n\n\n规范化\n目录结构的划分、编码规范化、接口规范化、文档规范化、 Git 分支管理\n\n\n自动化\n自动化构建、自动部署、自动化测试\n\n\n\n\nWebpack\n概念\nwebpack 是前端项目工程化的具体解决方案。提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JavaScript 的兼容性、性能优化等强大的功能。让程序员把工作的重心放到具体功能的实现上，提高了前端开发效率和项目的可维护性。\n\n\nwebpack全局安装\nnpm install webpack webpack-cli -D\n\n\nwebpack配置项\n在webpack.config.js中进行配置\n\nwebpack的基本配置项及插件配置\n\n基本配置项\nmode\n\n ① development — 开发环境 \n\n不会对打包生成的文件进行代码压缩和性能优化 \n\n打包速度快，适合在开发阶段使用\n\n ② production ——生产环境 \n\n 会对打包生成的文件进行代码压缩和性能优化 \n\n打包速度很慢，仅适合在项目发布阶段使用\n\n\n\nentry/output\n\n通过 entry 节点指定打包的入口。通过 output 节点指定打包的出口\n\n\n\n\n插件配置项\n1 webpack-dev-server\n\n让 webpack 监听项目源代码的变化，从而进行自动打包构建。\n\n\n2 html-webpack-plugin\n\n通过 html-webpack-plugin 插件，将 src 目录下的 index.html 首页，复制到项目根目录中一份,将页面放入到内存中\n\n\n3 devServer\n\n控制打包后是否自动打开/访问路径/自定义端口号\n\n\n\n\nloader加载\n打包处理css\n\n打包处理less\n\n打包处理路径图片\n\n打包处理高级JS语法\n\n\n\n\n\nSourceMap\n作用：精准定位到错误行并显示对应的源码 方便开发者调试源码中的错误\n\n开发实践\n\n① 开发环境下：\n\n把 devtool 的值设置为 eval-source-map\n\n好处：可以精准定位到具体的错误行\n\n\n\n② 生产环境下：\n\n建议关闭 Source Map 或将 devtool 的值设置为 nosources-source-map\n\n好处：防止源码泄露，提高网站的安全性\n\n\n\n\n\n\n\n\n\n\n","categories":["前端工程化"],"tags":["Webpack"]},{"title":"vue基础——特性/指令/过滤器/侦听器/计算属性","url":"/VUE/VUE-study/vue-base-2022-02.html","content":"VUE特性\n① 数据驱动视图：\n\n优点：当页面数据发生变化时，页面会自动重新渲染页面的结构\n\n⚠️注意：数据驱动视图是单向的数据绑定。\n\n\n\n ② 双向数据绑定\n\n优点：不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中\n\n\nMVVM——Model、View 、 ViewModel\n具体结构\n\nModel 表示当前页面渲染时所依赖的数据源。\n\nView 表示当前页面所渲染的 DOM 结构。\n\nViewModel 表示 vue 的实例，它是 MVVM 的核心。\n\n\n\n工作原理\n\n当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构\n\n当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中\n\n\n\nMVVM具体结构的对应关系\n\n\nVUE指令\n① 内容渲染指令\n\nv-text：\n\n放在标签内使用,只渲染纯文本\n\nv-text 指令会覆盖元素内默认的值。\n\n\n\n 插值表达式——&#123;&#123;msg&#125;&#125;\n\n它不会覆盖元素中默认的文本内容，只渲染纯文本\n\n⚠️：除了支持绑定简单的数据值之外，还支持 Javascript 表达式的运算:三元表达式/数字计算/数组修改\n\nv-html\n\n将包含 HTML 标签的字符串渲染为页面的 HTML 元素\n\n\n\n\n② 属性绑定指令——v-bind/：\n\n为元素的属性动态单向绑定属性值\n\n\n③ 事件绑定指令——v-on/@\n\n为 DOM 元素绑定事件监听,eg:：@click、 @input、@keyup\n\n绑定的事件处理函数，需要在 methods 节点中进行声明\n\n常用事件修饰符——@event.事件修饰符\n\n按键修饰符——.enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right\n\n事件对象$event\n\n注意在事件中要使用 $event 符号\n\n获取当前事件元素：e.target\n\n\n\n\n\n④ 双向数据绑定指令——v-model\n\n常用修饰符\n\n\n⑤ 条件渲染指令——v-if/v-show\n\n实现原理\n\nv-if 指令会动态地创建或移除 DOM 元素，从而控制元素在页面上的显示与隐藏, 有更高的切换开销；\n\nv-show 指令会动态为元素添加或移除 style=”display: none;” 样式，从而控制元素的显示与隐藏,更高的初始渲染开销；\n\n\n\n实际使用\n\n如果需要非常频繁地切换——使用 v-show\n\n如果在运行时条件很少改变——使用 v-if\n\n\n\n\n\n⑥ 列表渲染指令——v-for\n\n&lt;tr v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt;&lt;/td&gt;\n\n索引\n\n这里仅仅指的是它当前的位置，而不是绑定的元素/数据\n\nv-for 指令中的 item 项和 index 索引都是形参，可以根据需要进行重命名。例如 (user, i) in userlist\n\n\n\n维护列表的状态——key\n\nkey 的值只能是字符串或数字类型 key 的值必须具有唯一性（即：key 的值不能重复）\n\n建议把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性） \n\n使用 index 的值当作 key 的值没有任何意义（因为 index 的值不具有唯一性）\n\n 建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱）\n\n\n\n\n\n\n文本格式化——过滤器:filters()\n基本用法:\n\n本质上是函数，需定义在fliters下\n\n在过滤器函数中，一定要有 return 值\n\n在html语句中的插值表达式内利用管道符插入相关处理函数： &lt;p&gt;message 的值是：&#123;&#123; message | capi &#125;&#125;&lt;/p&gt;\n\n ⚠️注意：过滤器函数形参可以有其他的参数，但是其默认的第一参数—— val，永远都是“管道符”前面的那个值\n\n\n\n过滤器分类\n\n全局过滤器\n\n具体格式：Vue.filter(&#39;过滤器名称&#39;, function (参数)&#123; &#125; ) \n\n优点：具有复用性\n\n\n\n私有过滤器：直接在vm中调用\n\n\n\n调用原则——就近：如果全局过滤器和私有过滤器名字一致，此时按照“就近原则”，调用的是”私有过滤器“\n\n未完成：完善案例：时间格式化\n\n\n监视数据变化——侦听器:watch:{}\n语法格式:侦听器本质上是一个函数，把数据名作为方法名。新值在前，旧值在后\n\n侦听器格式：\n\n方法格式：\n\n具体格式参考：可以看到将数据dataname作为方法名(newVal)\n\n缺点：\n\n1：无法在刚进入页面的时候，自动触发\n\n2：如果侦听的数据data中是一个对象，如果对象中的属性发生了变化，不会触发侦听器！！！\n\n\n\n\n\n对象格式：\n\n具体格式参考：此时需要一个handler(newVal,oldVal)的处理函数进行传值\n\n优点：\n\n1：侦听器自动触发—— immediate 选项\n\nimmediate为boolean类型，默认为false，如果为true则设置自动触发一次\n\n\n2：侦听器深度监听对象中每个属性的变化—— deep 选项\n\ndeep选项为boolean类型，默认为false，如果为true，只要对象中任何一个属性变化了，都会触发“对象的侦听器”\n\n⚠️注意：如果要单独侦听对象子属性的变化，则必须包裹一层单引号——‘info.username’(newVal) {}\n\n\n\n\n\n\n\n\n\n\n计算属性——computed()\n定义的时候，要被定义为“方法”,但本质是一个属性\n\n具体格式：写在computed:&#123;&#125;中，属性要定义为方法格式\n\n优点：\n\n实现了代码的复用\n\n只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值！\n\n\n\n\n","categories":["VUE"],"tags":["VUE"]},{"title":"Algorithm","url":"/Algorithm/Algorithm/page-2022-03.html","content":"\n数组\n\n创建数组\n\n创造指定长度的空数组:const arr = new Array(数组长度)\n\n创建一个长度确定、同时每一个元素的值也都确定的数组(每个都是1）：const arr = (new Array(7)).fill(1)\n\n\n\n访问:直接在中括号中指定其索引\n\n遍历数组:\n\n如果没有特殊的需要，那么统一使用 for 循环来实现遍历。因为从性能上看，for 循环遍历起来是最快的。\n\nfor 循环\n\nforEach 方法：可以取到数组每个元素的值及其对应索引\n\nmap 方法——返回新数组遍历的基础上“再加工”\n\n\n\n二维数组=矩阵\n\n初始化：for 循环\n\n访问：两遍for循环\n\n\n\n问题：关于二维数组使用fill的局限性\n\n当用const arr =(new Array(7)).fill([])初始化数组时，此时将arr[0][0] = 1会发现一整列元素都会变成1当给 fill 传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用这7个数组对应了同一个引用、指向的是同一块内存空间，它们本质上是同一个数组。因此当你修改第0行第0个元素的值时，第1-6行的第0个元素的值也都会跟着发生改变。\n\n\n灵活增删的数组 \n\n数组增加元素的方法：\n\nunshift 方法-添加元素到数组的头部\n\nunshift 方法-添加元素到数组的头部\n\nsplice 方法-添加元素到数组的任何位置arr.splice(start,数量,item值) // [1,3,2]\n\n\n\n\n\n\n\n\n","categories":["Algorithm"],"tags":["Algorithm-基础笔记"]},{"title":"连等赋值问题","url":"/Interview/%E9%9D%A2%E8%AF%95/20220225-2022-02.html","content":"坐着突然看到一个题，想了一下答错了，看了题解之后还是不太理解，终于在一个大佬的白话中get到卡住的点！\n解答地址：https://segmentfault.com/q/1010000002637728\n1.赋值表达式的概念：计算一般的赋值表达式 A = B按如下步骤：\n\n计算表达式A，得到一个引用refA；\n计算表达式B，得到一个值valueB；\n将valueB赋给refA指向的名称绑定；\n返回valueB。‘\n\n连等的核心思想：连等是先确定所有变量的指针，再让指针指向那个赋值\n对于题1:1 var a = b =10;2      (function()&#123;3          var a = b = 20;4       &#125;)();5 console.log(a);6 console.log(b);//问：输出的 a = ?    b = ?//10 20\n\n\n首先第一行的 var a = b = 10; 就是用了连等操作符，连等操作符是从右向左的 所以类似于b = 10; a = b;或者是 a = (b = 10);\n此时，变量a是用var进行声明并赋值的所以是局部变量，\n但是b是未声明而直接进行赋值的所以是全局变量。\n\n\n第二行开始使用匿名函数实现模仿块级作用于（私有作用域）:在里面声明的变量会在函数结束后被销毁除非被外部所使用\n第三行，先使用外部局部变量b，b =20; 然后又**重新声明了一个变量a**\n此时内部的局部新生成的a为20\n\n\n第四行声明定义一个匿名函数后随即执行，**私有作用域中创建的变量a在结束后随即被销毁**.所以最后改变的只有外部的变量b的值.\n此时b=20 ,a还是为之前外部的10\n\n\n\n对于题2:1 var a = &#123;n: 1&#125;;2 var b = a;3 a.x = a = &#123;n: 2&#125;;4 alert(a.x); // --&gt; 5 alert(b.x); // --&gt; \n\n\n第三行声明变量b，并且把a的对象引用赋值给b。\n\n此时，变量b和a指向的是同一个对象，即他们现在共享。\na:{n:2},b:{n:2}\n\n\n第四行:————连等是先确定所有变量的指针，再让指针指向那个赋值\n\n找到 a 和 a.x 的指针。如果已有指针，那么不改变它。如果没有指针，即那个变量还没被申明，那么就创建它，指向 null。\n此时，a 是有指针的，指向 &#123;n:1&#125;；\na.x 是没有指针的，所以创建它，指向 null。\n\n\n.运算优先于=赋值运算，因此此处赋值可理解为\n声明a对象中的x属性，用于赋值，此时b指向a，同时拥有未赋值的x属性\n对a对象赋值，此时变量名a改变指向到对象{n:2}\n对步骤1中x属性，也即a原指向对象的x属性，也即b指向对象的x属性赋值\n\n\n\n\n上图更明确：\n\n\n\n","categories":["Interview"],"tags":["javascript"]},{"title":"HTTP相关","url":"/Interview/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/HTTP%E7%9B%B8%E5%85%B3-2022-03.html","content":"应用层-HTTP、HTPS、DNSHTTP的特点？它有什么缺点？特点：\n端对端， 灵活可拓展，\n\n基于 TCP/IP-&gt;可靠\n\n每一次请求都是独立无关的-&gt; 无状态\n\n\n缺点：\n明文传输(不加密)，无法验证报文的完整性，不验证通信方的身份，内容可能被窃听、被篡改。\n\n无状态，它是缺点也是优点吧，分不同的场景。\n\n队头阻塞——HTTP2多路复用解决\n\nHTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。\n\nHTTP2中：\n\n同域名下所有通信都在单个连接上完成。单个连接可以承载任意数量的双向数据流。\n\n数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装\n\n\n\n\n\n\nHTTP请求报文（客户端）常用请求方法：\nGET: 通常用于请求服务器发送某些资源\n\nPOST: 发送数据给服务器\n\nPUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式\n\nDELETE: 用于删除指定的资源\n\nCONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器\n\nOPTIONS: 用于获取目的资源所支持的通信选项\n\n\nGET(检索&amp;&amp;获取）/POST（创建||更新）区别\n参数角度：get在URL中，post在请求体中,并且post支持更多数据类型\n\n缓存安全性不同：浏览器一般会对 Get 请求缓存，很容易通过历史记录、缓存查到数据信息。但很少对 Post 请求缓存。get可以回退/post不可以回退\n\n数据类型不同：get使用url发送数据，使用的百分号编码,不是简单的ASCII码（比如{，不能够在url直接使用）\n\n应用场景：get安全幂等，不会引起服务器状态变化。\n\n自己理解的话：在没有其他操作的情况下，get多次请求结果和一次请求结果相同。post非安全非幂等。\n\n\n\nPUT和POST都可以给服务器新增资源，有什么区别？\nPUT：幂等，URI指向单一资源。\n\nPOST：非幂等，URI指向资源集合。\n\neg：比如博客系统，创建新文章，用POST https://www.blog.com/articles,多次调用，就创建多个文章。如果更新指定文章的标题，用PUT https://www.blog.com/articles/000001,多次调用，和第一次调用效果相同。\n\n\nhttp 请求方法 options 方法有什么用？\n旨在发送一种探测请求，以确定针对某个目标地址的请求必须具有怎么样的约束，然后根据约束发送真正的请求。\n\n应用场景：针对跨域资源的预检，处理跨域请求。就是采用 HTTP 的 OPTIONS 方法先发送的。\n\n\n常见状态码：HTTP响应报文（服务端）HTTP的keep-alive是干什么的？\n早期HTTP/1.0每次请求都要重新建立一次连接，为了减少资源消耗、缩短响应时间，就要重用连接，想要保持长连接，需要在请求头上加上Connection:keep-alive。\n\nHTTP1.1 和 HTTP 1.0之向区别\nHTTP/1.0有GET、POST、HEAD三个请求方法\n\nHTTP/1.1新增了PUT、DELETE、PATCH、OPTIONS、TRACE、CONNECT 请求方法，并且支持了持久连接。\n\n\nDNS 为什么使用 UDP协议作为传输层协议?HTTPSRSA 加密(非对称加密)TLS/SSL证书\nTLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”\n\nSSL连按断开后如何饭复？\n\n\n浏览器存储强缓存和协商缓存\n浏览器缓存在加载页面中的应用\n\n浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）\n\n如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）\n\n如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）\n\n\n\n强缓存(Cache-Control)：只有首次请求和服务器通信，读取缓存不用向服务器发送请求。返回200\n\n协商缓存(ETag/If-None-Match)：总会与服务器交互，第一次是拿数据和ETag，之后凭ETag询问是否更新。返回304，从现有缓存加载资源 \n\n\ncookie/localStorage/sessionStorage三者区别Cookie和SessionCDN服务\nCDN服务是什么\n\n负载平衡的两种实现方式？\n\n什么是正向代理和反向代理？\n\n\n常见的网络攻击方法和解决方案？XSS（跨站脚本攻击）——获取被攻击者的账户信息\n攻击手段：攻击者往Web页面插入恶意代码，当用户浏览页面时，嵌入其中的script恶意代码就会执行。将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。\n\n场景：\n\n拼接url 获取用户敏感数据\n\n后台存在漏洞拼接sql 盗取数据库信息\n\n\n\n解决方案：\n\n过滤、、标签\n\n对&lt;、&gt;在输入的时候进行编码转换\n\n限制字符串长度\n\n使用 HttpOnly Cookie将重要的cookie标记为httponly，当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。\n\n\n\n\nCSRF（跨站请求伪造）——通过账号信息伪装成被攻击者实施攻击行为\n攻击手段：用户登录受信任的A网站，产生Cookie，在没有登出A的情况下，访问了危险的B网站，B要求访问第三方站点（A），并发送一个请求（request），然后B就带着之前的Cookie（伪装成用户的名义）去请求。\n\n解决方案：\n\n1.验证 HTTP Referer 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer记录了该 HTTP 请求的来源地址。\n\n优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。\n\n缺点：Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。\n\n\n\n 2.在请求地址中添加 token 并验证。在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。\n\n优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。\n\n缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。\n\n\n\n\n实现多个网站共享登陆状态/浏览器内多个标签页之间的通讯","categories":["Interview"],"tags":["计算机网络"]},{"title":"计算机网络","url":"/Interview/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/TCP%E5%92%8CUDP-2022-03.html","content":"\n知识点：\n进程和线程\n进程：内存中正在运行的应用程序\n\n线程：进程的最小执行单位\n\n浏览器采取了多进程模型（至少4个）\n\n浏览器进程主要负责界面显示、用户交互、子进程管理、同时提供存储等功能。\n\n渲染进程 核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都运行在该进程中，默认情况下，Chrome为每一个Tab标签页创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下的。\n\nGPU进程。GPU图形处理器（英语：graphics processing unit，缩写：GPU）,负责3D css效果，网页，Chrome ui的绘制。\n\n网络进程主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立处理，成为单独一个进程。\n\n插件进程。主要负责插件的运行，因为插件易崩溃，所以通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n\n\n\n\n计算机网络的ISO七层模型\n1、物理层：\n\n使用一定的物理介质(光纤，网线wifi）\n\n\n2、数据链路层：MAC地址 封裝 单位为byte\n\n通过网关进行通信 \n\n\n3、网络层：\n\nIP协议：将数据从主机A发送给主机B，不能保证肯定发送给目标\n\n\n4、传输层：具有端口，确保数据传输\n\nUDP(用户数据包协议）——只管发不管收——DNS\n\nTCP(传输控制协议)：\n\n重传机制\n\n排序机制：将主机A发给B的多个数据包按照编号进行排序进行重组，保证完整性\n\n相关面试题：TCP和UDP区别:面向连接/可靠性/基于字节流/TCP三次握手/TCP四次挥手\n\n\n\n\n\n5、会话层:\n\n断点续传\n\n\n6、表示层——翻译——解决不同系统数据之间传输的问题\n\n7、应用层：#问题\n\nHTTP协议：\n\n\n\n\nHTTP请求流程\n浏览器发送HTTP请求 \n\n1、构造请求行：GET /api/article HTTP/1.1\n\n2、查找缓存：有就去缓存存，没有呢就发选网络请求\n\n3、准备IP地址和端口号\n\n4、 等待TCP队列:因为一个域名最多只能生立6个TCP连接\n\n5、建立TCP连接\n\n6、发送HTTP请求\n\n版本2:\n\n1、先查找缓存，检测缓存是否过期，直接返回缓存中内容\n\n2、看域名是否被解析，DNS协议，DNS协议是基于UPD协议  ip+端口号 \n\n3、ip地址寻址，排队等候，最多发送6个http请求\n\n4、tcp创建链接，用户传输(三次握手)\n\n5、利用tcp传输数据(拆分数据包，有序)  可靠，有序，服务器会按照顺序来接受\n\n6、http请求(请求行，请求头，请求体)\n\n7、默认不会断开keep-alive，为下次传输数据是，可以复用上次的创建的连接\n\n8、服务器接受数据后(响应行 响应头 响应头)\n\n\n\n\n\n\n\n输入url地址到显示的过程\n进程角度：\n\n其他角度\n\n\n\n\n\n常见面试题\n一次完整的http服务过程\n一次完整的http服务的几个阶段\n\nhtml的渲染过程\n\n常见的http请求状态码\n\n\n\n传输层——TCP/UDP相关\nTCP和UDP区别:面向连接/可靠性/基于字节流\nTCP是基于连接的，可靠性高(有状态/可控制/TCP流量控制/TCP拥塞控制)，安全，但是相同数据下开销大；只支持点到点连接，面向字节流\n\n有状态；TCP会精准记录哪些数据发送了，被对方接受了，哪些没有，而保证数据按序到达，不允许差错 \n\n可控制；意识到丢包或者网络环境差，TCP根据具体情况调整自己的行为，控制自己发送速度或重发\n\n\n\nUDP是基于无连接的，可靠性较低，实时性高，会存在丢包问题，支持多种连接方式\n\n应用场景的区别：\n\n如果对实时性要求高和高速传输/可靠性要求低追求效率的场景下需要使用UDP；\n\n如果需要传输大量数据且对数据可靠性要求高的场景使用TCP；\n\n\n\n\n\nTCP三次握手\n握手过程：确认双方的两样能力: 发送的能力和接收的能力\n\n1.最开始双方都属于CLOSED状态。然后服务器开始监听某个端口，进入LISTEN状态。\n\n2.客户端注重发起连接，发送SYN，自己变成了SYN-SENT状态\n\n3.服务端收到，返回SYN和ACK（对应客户端发来的SYN），自己变成了SYN-REVD\n\n4.客户端再发送ACK给服务端，自己变成ESTABLISHED（established）状态；服务端收到ACK之后，也变成这个状态\n\n#注意：SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1凡是需要对端确认的，一定消耗TCP报文的序列号。\n\n\n\n为什么不是两次？\n\n两次握手只能确定从 客户端 到 服务端 的网络是可达的，但却无法保证从 服务端 到 客户端 的网络是可达的。第三次握手就是为了确定从 服务端 到 客户端 的网络是否可达，两次握手，服务端只要接收到然后发送相应的数据包，就 默认连接 了 ，但是事实上现在客户端可能已经断开连接了，这样也就带来了连接资源的浪费 \n\n\n为什么不是四次？\n\n当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。\n\n\n三次握手过程中可以携带数据么？\n\n可以，但是只有第三次，此时的established状态相对安全并且够确认服务器的接收发送能力。而不能在第一次握手携带数据是为了防止黑客在syn中放入大量数据造成服务器资源的消耗。\n\n\n\n\nTCP四次挥手\n过程\n\n首先客户端主动关闭，向服务器发FIN报文\n\n服务端接收后通知应用进程并向客户端发送ACK确认\n\n服务端处理完后被动关闭再次向客户端发送FIN以及ACK，进入LAST-ACK状态，\n\n客户端收到服务端发来的FIN后，发送 ACK 给服务端。在等待2MSL后进入CLOSED状态\n\n\n\n#问题 为什么要等待2MSL（最长报文段寿命）\n如果客户端没有收到服务端的重发请求，表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。\n\n1 个 MSL 确保四次挥手中第四步的ACK可以准确到达\n\n1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达\n\n如果不等待：当服务端还有很多数据包要给客户端发，此时客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。\n\n\n\n为什么不是三次？\n\n如果三次，服务端将ACK和FIN的发送合并为一次挥手，这个时候为了传递没有完成的数据，长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。\n\n因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。\n\n\n\n\n\nSYN Flood 攻击原理\n原理:典型的 DoS/DDoS 攻击。用客户端在短时间内伪造大量不存在的 IP地址，并向服务端疯狂发送SYN。\n\n处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。\n\n由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。\n\n\n\n应对方法: \n\n增加 SYN 连接，也就是增加半连接队列的容量。\n\n减少 SYN + ACK 重试次数，避免大量的超时重发。\n\n利用 SYN Cookie技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证Cookie 合法之后才分配连接资源。\n\n\n\n\n\nTCP 短连接和长连接的区别\n短连接：\n\nClient 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。\n\n优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。\n\n\n\n长连接：\n\nClient 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。\n\n应对策略：\n\n关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；\n\n以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。\n\n\n\n\n\n\n\nTCP可靠性特质\nTCP流量控制\n\nTCP拥塞控制\n\n\n\n粘包拆包问题（消息边界问题）\n场景\n假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。\n\n成功结果：服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；\n\n失败1：服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；\n\n失败2：服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；\n\n失败3：服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。\n\n\n\n如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。\n\n\n\n\n\n\n\n\n","categories":["Interview"],"tags":["计算机网络"]},{"title":"浏览器输入URL过程详解","url":"/Interview/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url-2022-03.html","content":"\n重要！当你在浏览器中输入 Coogle.com 井且按下回车之后发生了什么？\n这篇写的太详细了！https://juejin.cn/post/6844904021308735502#heading-46\n\n网络方面\n\n总结过程\n\n\\1. 构建请求：浏览器会构建请求行:\n\n\\2. 查找强缓存：浏览器缓存在加载页面中的应用先检查强缓存，如果命中直接使用，否则进入下一步。\n\n\\3. DNS解析域名\n\n由于我们输入的是域名，而数据包是通过IP地址传给对方的。因此我们需要得到域名对应的IP地址。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做DNS（域名系统）。得到具体 IP 的过程就是DNS解析。\n\n注意：浏览器提供了DNS数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS解析。如果不指定端口的话，默认采用对应的 IP 的 80 端口。\n\n\n\n\\4. 建立 TCP 连接\n\n注意：Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就得等待。\n\n建立 TCP连接经历了下面三个阶段:\n\n通过TCP三次握手(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接。\n\n进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。\n\n优化策略：拆包——就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。\n\n\n断开连接的阶段。数据传输完成，现在要断开连接了，通过TCP四次挥手来断开连接。\n\n\n\n\n\n5.发送 HTTP 请求TCP连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。\n\n6.网络响应HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。​\n\n7.响应完成，判断Connection字段是否建立持久连接\n\n如果请求头或响应头中包含Connection: Keep-Alive，表示建立了持久连接，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。否则断开TCP连接, 请求-响应流程结束。\n\n\n\n\n解析算法篇\n浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）\n\n生成布局树(Layout Tree)\n\n样式计算【解析CSS文件（将其转化为一个结构化的对象，即styleSheets）构建渲染树】\n\n构建 DOM树\n\n\n\n渲染过程\n\n建立图层树(Layer Tree)\n\n生成绘制列表渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框……然后将这些指令按顺序组合成一个待绘制列表\n\n生成图块并栅格化\n\n显示器显示内容\n\n\n\n\n\n\n","categories":["Interview"],"tags":["计算机网络"]},{"title":"element-ui/tab栏切换再加载问题","url":"/work/work/el-tab%E6%A0%8F-2022-04.html","content":"错误1：切换tab栏发现echarts组件缩放失效解决方式：\nel-tab中的lazy属性，可以在切换的时候重新渲染\n\n错误2：el-tab延迟加载lazy属性解决了echarts的显示问题，但是我发现当你把全部tab栏全部切换一遍之后，再切换就不重新渲染了…我的子组件就拿不到数据了\n解决方式：为tab-panel添加key属性，v-if判断当前激活的tab内容，这样就不会同时把其他的也渲染出来，需要哪个渲染哪个。\n&lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleClick&quot;&gt;         &lt;el-tab-pane v-for=&quot;(item,index) in tabsArr&quot; :key=&quot;index&quot; :label=&quot;item.label&quot; :name=&quot;item.name&quot;&gt;           &lt;SettleTabData :settleData=&quot;settleData&quot; v-if=&quot;item.name == activeName&quot;&gt;&lt;/SettleTabData&gt;         &lt;/el-tab-pane&gt;&lt;/el-tabs&gt;\n\n data() &#123;   return &#123;     tabsArr: [       &#123;         label:&quot;待审批&quot;, name:&quot;first&quot;       &#125;,       &#123;         label:&quot;待支付&quot;, name:&quot;second&quot;       &#125;,       &#123;         label:&quot;已支付&quot;, name:&quot;third&quot;       &#125;,       &#123;         label:&quot;全部&quot;, name:&quot;fourth&quot;       &#125;     ],     activeName: &#x27;second&#x27;,     settleData: [&#x27;second&#x27;, &#x27;month&#x27;],     date: [&#x27;&#x27;, &#x27;&#x27;],     status: &#x27;month&#x27;   &#125; &#125;,methods: &#123;   // tab切换   handleClick() &#123;     console.log(&#x27;activeName&#x27;, this.activeName)     this.settleData[0] = this.activeName   &#125; &#125;,","categories":["work"],"tags":["VUE","场景错误"]},{"title":"Echarts切换图表-toolbox.feature使用官方的/自定义","url":"/work/work/echarts%E5%9B%BE%E8%A1%A8%E5%88%87%E6%8D%A2-2022-04.html","content":"Echarts切换图表-toolbox.feature使用官方的/自定义1.柱状图和折线图可以通过官方的magicType来进行切换feature: &#123;  magicType:     &#123;      type:         [&#x27;line&#x27;, &#x27;bar&#x27;] //图表类型切换     &#125;  ,&#125;, \n\n2.但是饼状图不行，需要在里面自定义函数，如下&lt;template&gt;  &lt;div class=&quot;w-full h-full&quot;&gt;    &lt;v-chart :options=&quot;options&quot;&gt;    &lt;/v-chart&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ECharts from &#x27;vue-echarts&#x27;import &#x27;echarts/lib/component/legend&#x27;import &#x27;echarts/lib/component/title&#x27;import &#x27;echarts/lib/component/tooltip&#x27;import &#x27;echarts/lib/component/toolbox&#x27;import &#x27;echarts/lib/chart/line&#x27;import &#x27;echarts/lib/chart/pie&#x27;export default &#123;  components: &#123;    &#x27;v-chart&#x27;: ECharts  &#125;,  props: &#123;    chartsData: &#123;      type: Object    &#125;  &#125;,  data() &#123;    return &#123;      ProjectData: [],      options: &#123;&#125;,    &#125;  &#125;,  mounted() &#123;    this.getList()  &#125;,  methods: &#123;    getList() &#123;      // 按项目数据      // this.ProjectData=this.chartsData.ProjectData      this.ProjectData = [        &#123; value: 1048, name: &#x27;Search Engine&#x27; &#125;,        &#123; value: 735, name: &#x27;Direct&#x27; &#125;,        &#123; value: 580, name: &#x27;Email&#x27; &#125;,        &#123; value: 484, name: &#x27;Union Ads&#x27; &#125;,        &#123; value: 300, name: &#x27;Video Ads&#x27; &#125;]      this.$nextTick(function () &#123;        this.BarChange()        // this.randerEcharts()      &#125;)    &#125;,    // 变为饼状图    BarChange() &#123;      // 这里怎么传数据传5个图的呢      let echartsData = this.ProjectData.map(item =&gt; &#123;        return &#123;          value: item.value,          name: item.name        &#125;      &#125;)      let that = this      that.options = &#123;        tooltip: &#123;          trigger: &#x27;item&#x27;,          // 提示格式          formatter: &#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125;个 (&#123;d&#125;%)&#x27;,        &#125;,        toolbox: &#123;          show: true,          feature: &#123;            dataView: &#123; show: true, readOnly: false &#125;,            myLineTool: &#123;              show: true,              title: &#x27;切换为折线图&#x27;,              icon: &#x27;path://M163.84 880.64h122.88v-737.28h-122.88v737.28z m-40.96-778.24h204.8v819.2h-204.8v-819.2z m286.72 204.8h204.8v614.4h-204.8v-614.4z m40.96 573.44h122.88v-532.48h-122.88v532.48z m245.76-368.64h204.8v409.6h-204.8v-409.6z m40.96 368.64h122.88v-327.68h-122.88v327.68z&#x27;,              onclick: function () &#123;                that.LineChange()                // that.randerEcharts()              &#125;            &#125;,            myPieTool: &#123;              show: true,              title: &#x27;切换为饼状图&#x27;,              icon: &#x27;path://M512 0a512 512 0 1 0 512 512A512 512 0 0 0 512 0z m460.1856 489.8816H537.6V52.0192a461.2096 461.2096 0 0 1 434.5856 437.8624z m0 51.2a458.752 458.752 0 0 1-93.3888 249.4464L582.0416 541.0816zM512 972.8a460.8 460.8 0 0 1-25.6-921.6v464.2816a25.8048 25.8048 0 0 0 9.8304 20.48L845.6192 829.44a459.776 459.776 0 0 1-333.6192 143.36z&#x27;,              onclick: function () &#123;                that.BarChange()                // that.randerEcharts()              &#125;            &#125;,          &#125;        &#125;,        legend: &#123;          orient: &#x27;vertical&#x27;,          left: &#x27;left&#x27;,        &#125;,        series: [          &#123;            name: &#x27;Access From&#x27;,            type: &#x27;pie&#x27;,            // 半径&amp;位置            radius: &quot;80%&quot;,            center: [&#x27;50%&#x27;, &#x27;50%&#x27;],            data: echartsData,            emphasis: &#123;              itemStyle: &#123;                shadowBlur: 10,                shadowOffsetX: 0,                shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27;              &#125;            &#125;          &#125;        ]      &#125;    &#125;,    // 变为线形图    LineChange() &#123;      let lineData = this.ProjectData      let xList = lineData.map(item =&gt; item.name)      let data = lineData.map(item =&gt; item.value)      let that = this      that.options = &#123;        tooltip: &#123;          trigger: &#x27;axis&#x27;,          axisPointer: &#123;            type: &#x27;cross&#x27;          &#125;        &#125;,        legend: &#123;          orient: &#x27;vertical&#x27;,          left: &#x27;left&#x27;,        &#125;,        toolbox: &#123;          show: true,          feature: &#123;            myTool1: &#123;              show: true,              title: &#x27;切换为折线图&#x27;,              icon: &#x27;path://M163.84 880.64h122.88v-737.28h-122.88v737.28z m-40.96-778.24h204.8v819.2h-204.8v-819.2z m286.72 204.8h204.8v614.4h-204.8v-614.4z m40.96 573.44h122.88v-532.48h-122.88v532.48z m245.76-368.64h204.8v409.6h-204.8v-409.6z m40.96 368.64h122.88v-327.68h-122.88v327.68z&#x27;,              onclick: function () &#123;                that.LineChange()              &#125;            &#125;,            myTool: &#123;              show: true,              title: &#x27;切换为饼状图&#x27;,              icon: &#x27;path://M512 0a512 512 0 1 0 512 512A512 512 0 0 0 512 0z m460.1856 489.8816H537.6V52.0192a461.2096 461.2096 0 0 1 434.5856 437.8624z m0 51.2a458.752 458.752 0 0 1-93.3888 249.4464L582.0416 541.0816zM512 972.8a460.8 460.8 0 0 1-25.6-921.6v464.2816a25.8048 25.8048 0 0 0 9.8304 20.48L845.6192 829.44a459.776 459.776 0 0 1-333.6192 143.36z&#x27;,              onclick: function () &#123;                that.BarChange()              &#125;            &#125;,          &#125;        &#125;,        xAxis: &#123;          type: &#x27;category&#x27;,          data: xList        &#125;,        yAxis: &#123;          type: &#x27;value&#x27;,          axisLine: &#123;            show: true,          &#125;,        &#125;,        series: [          &#123;            data: data,            type: &#x27;bar&#x27;,            name: &#x27;数量&#x27;,            barMaxWidth: 22          &#125;        ]      &#125;    &#125;,  &#125;,&#125;&lt;/script&gt;&lt;style&gt;.echarts &#123;  width: 100%;  height: 100%;&#125;&lt;/style&gt;\n\n","categories":["work"],"tags":["场景错误","Echarts"]},{"title":"vue中 let that=this的作用","url":"/work/work/that=this-2022-04.html","content":"最近在写图表切换的时候，发现设定echarts option往往先让that=this，然后再使用this，不知道为什么这样，所以记录一下：\nthis 会随着上下文环境而变换它的指向，在当前作用域中设置一个变量用来存储 this 可以防止在其他地方找不到 this 的错误\n在Vue中this始终指向Vue，但一些其他组件如axios中this为undefined\n通过 let that = this   将this保存在that中，再在函数中使用that均可\n","categories":["work"],"tags":["VUE"]},{"title":"PaddleSpeech ST 数据预处理问题","url":"/ST/ST/Paddle-dataprocess-2022-05.html","content":"数据预处理：构建字典已经成功，train的时候提示fbank特征提取处理有点问题，数据格式报错\n原因：经大佬指点，发现是数据的格式有问题，fbank处理的为单通道，采样率为16000HZ的声音\n内心os:原来直接第一步数据处理就错了hhhhhh\n解决方式：编写shell利用sox批量处理音频至16000单通道\n#!/bin/bashfor x in ./*.wavdo   b=$&#123;x##*/&#125;  sox $b -c1 -r 16000 new_$b #-c1为单通道 -r 16000为采样率变为16000   rm -rf $b  mv new_$b $bdone\n\n成功后重新运行data.sh，重新进行数据预处理就很顺利了\n现在的问题是：每次识别的都一样😂肯定还有问题，继续解决ing\n","categories":["ST"],"tags":["PaddleSpeech"]},{"title":"剑指Offer-09/30","url":"/Algorithm/Algorithm/stack-2022-05.html","content":"剑指 Offer 09. 用两个栈实现队列\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n\n示🌰：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]\n\n思路：\n分别声明两个栈，A栈负责模拟入队，B栈负责模拟出队\n\nvar CQueue = function() &#123;    this.stackA=[]    this.stackB=[]&#125;;// 入队操作CQueue.prototype.appendTail = function(value) &#123;    this.stackA.push(value)&#125;;// 出队操作CQueue.prototype.deleteHead = function() &#123;    // 判断B是否为空    if(this.stackB.length)&#123;        return this.stackB.pop()    &#125;    else&#123;        // B为空且A也为空，返回-1        if(!this.stackA.length)&#123;            return -1        &#125;        // B为空但是A不为空，将A的值先依次出栈压入B中，然后B再pop        else&#123;            while(this.stackA.length)&#123;                this.stackB.push(this.stackA.pop())            &#125;        &#125;         return this.stackB.pop()    &#125;    &#125;;\n\n剑指 Offer 30. 包含min函数的栈\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n\n示🌰：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.min();   --&gt; 返回 -2.\n\n思路：\n声明两个栈，一个数据栈，一个单调递减的最小栈\n\n1.入栈时，如果最小栈为空，或者新元素小于或等于最小栈栈顶，则将新元素压入最小栈，最小栈的栈顶永远是最小元素 2.出栈时，如果出栈元素和最小栈栈顶元素值相等，如果要弹出的元素同时存在于最小栈中，就一起弹出\nvar MinStack = function() &#123;    this.stack=[]    this.minstack=[]&#125;;MinStack.prototype.push = function(x) &#123;    this.stack.push(x)    // 这里要判断等于x，只有最小栈为空，新元素 小于等于 最小栈栈尾，才移入，因为要维护单调栈    if(!this.minstack.length||this.minstack[this.minstack.length-1]&gt;=x)&#123;        this.minstack.push(x)    &#125;&#125;;MinStack.prototype.pop = function() &#123;    // 方法1:用val来记录pop的值然后判断返回    // let val=this.stack.pop()    if(this.minstack[this.minstack.length-1]==this.stack.pop())   &#123;       return this.minstack.pop()    &#125;    return this.stack.pop&#125;;MinStack.prototype.top = function() &#123;    // 返回stack的栈顶值    return this.stack[this.stack.length-1]&#125;;MinStack.prototype.min = function() &#123;    // 返回minstack的栈顶值    return this.minstack[this.minstack.length-1]&#125;;\n","categories":["Algorithm"],"tags":["LeetCode","剑指offer"]},{"title":"手写call/apply/bind及理解","url":"/uncategorized/JS-study/%E6%89%8B%E5%86%99/apply-2022-05.html","content":"共同点：功能一致——可以函数体内的改变this指向\n但是只是调用改变，本身不改变\n\n语法： 函数.call()、函数.apply()、函数.bind()\n\n\n区别区别：\n\ncall、apply可以立即执行。bind不会立即执行，因为bind返回的是一个函数需要加入()执行。\n\n参数不同：apply第二个参数是数组。call和bind有多个参数需要挨个写。\n\n\n场景：一般用call\nMath.max数组求最大值：使用apply()\n\nbind场景\n\n\n手写一下这里先写上一个用于改变指向的function\nfunction A(name, age) &#123;      this.name = name;      this.age = age;      this.hobby = function (...params) &#123;        console.log(&#x27;name:&#x27;, this.name, &#x27;,age:&#x27;, this.age, &#x27;params:&#x27;, ...params)      &#125;    &#125;const Aa = new A(&#x27;haha&#x27;, 18)//一般调用    Aa.hobby.call(&#123;      name: &#x27;feifei&#x27;,      age: 28    &#125;)\n\nCall// 手写call     Function.prototype.myCall = function (context, ...args) &#123;       context = context ? context : window       context.fn = this       var result = context.fn(...args)       delete context.fn       return result     &#125;     Aa.hobby.myCall(&#123;       name: &#x27;feifei&#x27;,       age: 28     &#125;, 1, 3, 4)\n\nApply// 手写apply     Function.prototype.myApply = function (context, args) &#123;       context = context ? context : window       context.fn = this       var result = context.fn(...args)       delete context.fn       return result     &#125;     Aa.hobby.myApply(&#123;       name: &#x27;huhu&#x27;,       age: 9     &#125;, [1, 2, 3])\n\nBind// 手写bindFunction.prototype.myBind = function (context, ...args) &#123;  const fn = this  args = args ? args : window  return function newFn(...newFnArgs) &#123;    // 返回新的函数,要考虑到使用new去调用,并且new的优先级比较高,所以需要判断new的调用    // if (this instanceof newFn) &#123;    //   return new fn(...args, ...newFnArgs)    // &#125;    return fn.apply(context, [...args, ...newFnArgs])  &#125;&#125;Aa.hobby.myBind(&#123;  name: &#x27;feifei&#x27;,  age: 28&#125;, 1, 3, 4)()\n\n","tags":["JS"]}]